<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习之SVM基础</title>
      <link href="/2024/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h1><h2 id="SVM能做什么"><a href="#SVM能做什么" class="headerlink" title="SVM能做什么"></a>SVM能做什么</h2><p>支持向量机(Support Vector Machines)简称SVM，是一种既可用于回归又可用于分类的监督学习的模型。此文章重点讨论<mark>分类</mark>。</p><p>我们设计一个超平面，将两类数据区分开来，从而达到分类的效果。<br><img src="/images/Pasted image 20241203150820.png" style="zoom:200%;"/><br>SVM关心的点就是怎样找到一个最优秀的超平面：$$w^T x + b &#x3D; 0$$或者说，我们怎么拿到这个w和b。</p><h2 id="相关必要概念"><a href="#相关必要概念" class="headerlink" title="相关必要概念"></a>相关必要概念</h2><p>开始解决这个问题之前，我们穿插一些必要的概念：<br><img src="/images/Pasted image 20241204175554.png" style="zoom:200%;"/></p><ol><li>决策超平面(Decision Hyperplane)：也称作分类超平面，它将不同类别分开的超平面，就是我们要确定的超平面。 </li><li>正超平面(Positive Hyperplane)：与决策超平面平行，位于决策超平面一侧的超平面，它在样本空间中划分了属于正类的数据。</li><li>负超平面(Negative Hyperplane)：与决策超平面平行，位于决策超平面一侧的超平面，它在样本空间中划分了输入负类的数据。</li><li>间隔(Margin)：决策超平面与正超平面(或负超平面)之间的距离，或者说一类数据到决策超平面的最小距离。</li><li>支持向量：位于正负超平面上面的样本。</li></ol><h2 id="实现SVM分类器的问题转换"><a href="#实现SVM分类器的问题转换" class="headerlink" title="实现SVM分类器的问题转换"></a>实现SVM分类器的问题转换</h2><p>正负超平面之间的距离就是两类数据之间的距离，也就是两倍的间距。这个距离越大就说明两类数据之间差异越大，也就说明分类的效果好。要分类，那么我们就要<mark>最大化间距</mark>。</p><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>谈到距离，不防用高中数学中的点到直线距离过度一下。$$d &#x3D; \frac{|A x_0 + B y_0 + C|}{\sqrt{A^2 + B^2}}$$如此，点到超平面的距离也就不难理解了。<br>$$<br>d &#x3D; \frac{|w^T x + b|}{|w|},其中||w||&#x3D;\sqrt{w_1^2+w_2^2+…+w_n^2}<br>$$<br>相较于点到直线，多的仅仅是维度罢了。</p><p>公式当中的绝对值的作用显而易见，毕竟是距离，断然不该有负的概念。为了替换掉这个绝对值，我们引入y，当$w^T x_0 + b$本身为正时，我们乘上y（y&#x3D;1）；当$w^T x_0 + b$本身为负时，我们乘上y（y&#x3D;-1）。y要么为1要么为-1，就只有两种状态，正符合我们的二分类，我们可以把y视作分类的两种结果。</p><p>距离公式也就变成了$$d &#x3D; \frac{(w^T x^i + b)y^i}{|w|},\quad y^i &#x3D; \pm 1$$<br>那么：$$间隔&#x3D;min(数据到决策超平面的距离)&#x3D;min[ \frac{(w^T x^i + b)y^i}{|w|}],\quad y &#x3D; \pm 1$$那么我们的目标最大化间隔就等价于：$$max{min[\frac{(w^T x^i + b)y^i}{|w|}]},\quad y^i &#x3D; \pm 1$$这个式子就是我们的原始目标函数。</p><p>整体的函数就是一个分式，分母为||w||，分子为(wx+b)y（正数），很明显，在保证整体式子大小不变的情况下，我们调整分母的大小能够达到调整分子大小的效果。$$我们将||w||进行缩放，使得分子(w^T x^i + b)y^i&gt;&#x3D;1。$$<br>$$那么min[(w^T x^i + b)y^i]&#x3D;1$$<br>在原始的目标函数的基础上，将||w||提到前面来，我们得到：$$max{\frac{1}{||w||}min[(w^Tx^i+b)y^i]}$$<br>再将min替换掉，就得到：$$max(\frac{1}{||w||})$$别忘了我们能够将min替换掉是有一个前提的：$$(w^T x^i + b)y^i&gt;&#x3D;1$$所以完整来说，我们的目标函数变成了：$$max(\frac{1}{||w||})\quad s.t.(w^T x^i + b)y^i&gt;&#x3D;1$$<br>等价于：$$min(||w||)\quad s.t.(w^T x^i + b)y^i&gt;&#x3D;1$$<br>也等价于：$$min(\frac{1}{2}||w||^2)\quad s.t.(w^T x^i + b)y^i&gt;&#x3D;1$$<br>难免会好奇为什么将||w||加一个二分之一并且平方，这是一个好问题。<br>我们先回过头来想想，||w||是什么?||w||是二范式。$$||w||&#x3D;\sqrt{w_1^2+w_2^2+…+w_n^2}$$<br>不难想到，对二范式平方能避免根号的麻烦。至于前面的二分之一，就是为了求导和平方而得的2进行综合，系数又变成了1，省去许多计算麻烦。</p><p>到这里，我们的目标函数就变成了：$$min(\frac{1}{2}||w||^2),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1$$这样一系列推导下来，<mark><strong>我们要解决的问题就是一个带有不等式约束的最小化问题。</strong></mark></p><h3 id="公式推导-二"><a href="#公式推导-二" class="headerlink" title="公式推导(二)"></a>公式推导(二)</h3><p>推导过程也可以换一个思路来理解：<br>（这里我们假设是一个二维问题，超平面就是一条直线。）<br>我们将超平面的方程设出来$$正超平面：w_1x_1+w_2x_2+b&#x3D;c$$$$决策超平面：w_1x_1+w_2x_2+b&#x3D;0$$$$负超平面：w_1x_1+w_2x_2+b&#x3D;-c$$<br>我们可以同除以一个c，使得常数变为正负1。<br>方程式子就变成了这样：$$正超平面：\frac{w_1}{c}x_1+\frac{w_2}{c}x_2+\frac{b}{c}&#x3D;1$$$$决策超平面：\frac{w_1}{c}x_1+\frac{w_2}{c}x_2+\frac{b}{c}&#x3D;0$$$$负超平面：\frac{w_1}{c}x_1+\frac{w_2}{c}x_2+\frac{b}{c}&#x3D;-1$$对我们而言，想求的是自变量x前面的系数以及一个常数。所以w\c和w都是一样的，都只是代表一个未知量而已。所以我们将式子写成：$$正超平面：w_1x_1+w_2x_2+b&#x3D;1$$$$决策超平面：w_1x_1+w_2x_2+b&#x3D;0$$$$负超平面：w_1x_1+w_2x_2+b&#x3D;-1$$<br>为什么要除以一个c？<br>c可以随便缩放，那么这样的直线是有无数条的。<br>除以一个c，函数本质上其实是没有改变的，但是间距得到了改变。也就是说，我们通过除以c将超平面之间的偏差<mark>归一化</mark>为1。</p><p>我们从超平面方程跳到样本数据的方程。<br><img src="/images/Pasted image 20241204202629.png" style="zoom:200%;"/><br>位于正超平面的样本代入会有：$$w_1x_1+w_2x_2+b&#x3D;1$$正超平面即以上的样本代入会有（即正类数据）：$$w_1x_1+w_2x_2+b&gt;&#x3D;1$$同理：负类数据满足：$$w_1x_1+w_2x_2+b&lt;&#x3D;1$$将y&#x3D;1或-1引入，我们的数据满足的方程(也就是<mark>约束方程</mark>)就是：$$(w^Tx^i+b)y^i&gt;&#x3D;1$$<br>现在，我们做一些数学推导，需要提醒的是：<br>我们根据高中知识可以知道系数组成的向量就是法向量。所以w就是决策线的法线。<br><img src="/images/05d1be32da2775fa33c470e9b041d99.jpg" style="zoom:200%;"/><br>这里通过一个投影，我们将L引入，L就是正负超平面之间的距离，可以结合上面可视化进行理解。<br>通过推导我们得到了$$间距&#x3D;\frac{1}{2}L&#x3D;\frac{1}{||w||}$$再带上正负数据方程的约束，我们最大化间距问题为：$$max(\frac{1}{||w||})\quad s.t.(w^T x^i + b)y^i&gt;&#x3D;1$$就是我们明确的目标函数：$$min(\frac{1}{2}||w||^2),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1$$</p><h2 id="拉格朗日乘子法-KKT条件"><a href="#拉格朗日乘子法-KKT条件" class="headerlink" title="拉格朗日乘子法&amp;&amp;KKT条件"></a>拉格朗日乘子法&amp;&amp;KKT条件</h2><p>通过两个方向的解释，我们分类问题变成了带有不等式约束的最小化问题。为了解决这个问题我们就不得不提<mark>拉格朗日乘子法和KKT</mark>了。</p><p>最之前，我们提一下二者之间的关系：</p><blockquote><p>拉格朗日乘子法，解决的是等式约束下的最优化。而KKT是拉格朗日乘子法的扩展，能够解决含不等式约束的最优化问题。</p></blockquote><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><p>要理解拉格朗日乘子法，就避不开一个概念：梯度</p><blockquote><p>梯度是函数对每个变量的偏导数组成的向量。<br>   梯度指向函数值增长最快的方向。<br>   梯度总与函数等高线垂直，沿着与梯度成锐角的方向走，函数值增加；沿着与梯度成钝角的方向走一，函数值减小；沿着与梯度成直角方向走，函数值不变。</p></blockquote><p>我们要找到我们目标函数的最小值。<br>在某点上，我们求得目标函数的梯度以及约束函数的梯度。(图中以黄色向量和蓝色向量表示)</p><p>如果这个点是极值点</p><ol><li>对于目标函数而言，它不再能减小（或是增大），就是它的值不再能改变。函数值不变，也就说明我们要沿着与目标函数的梯度成直角的方向走。</li><li>对于约束函数而言，它要满足约束条件，不能变大也不能减小，所以自然也就是沿着于约束函数的梯度成直角的方向走。<br>综合下来，我们要走的方向既与目标函数梯度垂直又与约束函数梯度垂直。就能够推到：<br><mark><strong>在极值点上，目标函数的梯度共线于约束函数的梯度</strong></mark>，也就是：$$ \nabla f(x)&#x2F;&#x2F; \nabla c(x)$$<img src="/images/Pasted image 20241203194614.png" style="zoom:200%;"/><img src="/images/Pasted image 20241204214356.png" style="zoom:200%;"/><br>理解这个共线非常重要，可能我的表述有些不清楚，推荐观看哔站up主轩兔的视频<a href="https://www.bilibili.com/video/BV15T411f7DY/?spm_id_from=333.337.search-card.all.click&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">理解【拉格朗日乘数法】：有等号约束的最优化</a></li></ol><p>极值点应当满足两个式子：<br><img src="/images/Pasted image 20241204214611.png" style="zoom:200%;"/><br>第一个式子表达了我们刚才推导的共线，第二个式子表达了要满足约束条件。<br>简单来说的话就是：关于等式约束的最优化问题，我们代入上述两个式子，就能求得在约束条件下的极值。</p><p>我们构造一个函数：$$\mathcal{L}(x, \lambda) &#x3D; f(x) - \lambda c(x)$$我们将我们构造的这个函数称作拉格朗日函数，引入的一个常数叫做拉格朗日乘数。其中f(x)是目标函数，c(x)是约束函数。<br>令拉格朗日函数的梯度为0，我们就能拿到上面的两个关系式(共线以及满足约束)<br><img src="/images/Pasted image 20241203195044.png" style="zoom:200%;"/><br>实际上这里因为约束函数c(x)&#x3D;0，所以拉格朗日函数其实就是目标函数f(x)。<br>这里的将目标函数最小化，其实就是将拉格朗日最小化。<br>求拉格朗日函数的极小值，令其梯度为零，代入两个式子可以求得条件。</p><p>我们总结来说：要求等式约束下的极值，我们就构造拉格朗日函数，求拉格朗日函数的梯度，令其等于0，从而解得极值。</p><p>这里我们可以举一个例子作为结语。<br><img src="/images/ada29566d3e227c03f7c57670fa7d04.jpg" style="zoom:200%;"/></p><h3 id="KKT"><a href="#KKT" class="headerlink" title="KKT"></a>KKT</h3><p>定然，不是所有的约束都是等式约束。<br>不等式约束最优化问题我们可以分为两部分来看，先是小于约束(大于可转化为小于)，再是等于约束。<br>提醒：下图中的g(x)是约束函数，x*是最优解。<br><img src="/images/Pasted image 20241204220508.png" style="zoom:200%;"/></p><ol><li>约束函数小于0的情况是左图表现的情况，最小值在约束条件之内。此时，不考虑约束条件求得目标函数的极值也是在x*处，所以约束函数没有起到任何的作用，它不会影响到最小值的取值点。</li><li>约束函数等于0的情况，这个时候最值的取值肯定在约束边界上，其实就是上面拉格朗日乘子法解决的情况。</li></ol><p>总结一下两种情况，我们也就得到了KKT条件：<br><img src="/images/Pasted image 20241203195941.png" style="zoom:200%;"/><br>对于约束为不等式，我们就代入四个不等式，最后也就能求取答案。</p><h3 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h3><p>我们有必要提一提对偶：<br>什么是<mark>对偶函数</mark>？<br><strong>对偶函数</strong>（Dual function）是在约束优化问题中与原问题（也称为<strong>原始问题</strong>）相关的一个概念，它是通过拉格朗日乘子法引入的，旨在提供一个下界（对于最小化问题）或上界（对于最大化问题），并且通常比原始问题更易求解。</p><p>看这个定义是比较抽象的，我们通过拉格朗日函数来进行理解。</p><p>拉格朗日函数是这样的，通过拉格朗日乘子将约束函数引入。<br>提示：这里的h(x)是不等式约束，g(x)是等式约束。其中等式约束对应的拉格朗日乘子不做要求，而不等式约束对应的拉格朗日乘子必须要大于等于零。<br><img src="/images/Pasted image 20241203200342.png" style="zoom:200%;"/><br>因为加上的等式约束为0，不等式约束小于0。<br>所以我们所构造的拉格朗日函数一定是小于等于原函数f(x)的。也就是说，拉格朗日函数是原函数的下界，原函数是拉格朗日函数的上界。我们将拉格朗日函数称为原函数的对偶函数。可以通过求取对偶函数的上界(最大值)来求取原函数的下界(最小值)。</p><p>我们做出结论：<br>最小化问题当中，对偶问题的最优值一定是小于等于原始问题的最优值的。<br>对偶问题的上界就是原问题的下界。</p><p>为什么要求对偶问题？为什么要绕一个圈来解决原问题而不是直接解决？</p><ol><li>约束减少了。原问题中不等式约束有m个，等式约束有p个。而转化为对偶问题之后，原本的约束函数都变成了拉格朗日函数的乘子，我们就只要求不等式约束对应的拉格朗日乘子要大于等于零，只有m个约束。</li><li>对偶问题一定是凸优化问题。凸优化相较于非凸优化而言，优势在于凸优化的局部最优一定是全局最优。可以结合图形理解：<img src="/images/Pasted image 20241206174016.png" style="zoom:200%;"/>在拉格朗日对偶中，如何理解：无论原函数凸还是非凸，对偶函数一定是凸函数呢？<br>我们通过拉格朗日乘子将约束函数引入，对于拉格朗日函数而言，自变量已经变成了拉格朗日乘子而非原始的x，所以我们可以将拉格朗日函数看做关于λ和v的线性函数。线性函数就是凸函数的一种特殊形式。</li></ol><p>对偶问题点到即止了，简单来说就是，我们将原始问题求最小值转化为对偶问题拉格朗日函数求最大值。之后我们可以用凸优化来解决，可以用梯度法来处理，可以参考另一篇文章<a href="https://sorcerer.zeabur.app/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">机器学习之线性回归基础</a>当中提到的梯度下降。</p><h2 id="实现SVM基础小结"><a href="#实现SVM基础小结" class="headerlink" title="实现SVM基础小结"></a>实现SVM基础小结</h2><p>到此，我们已经能够实现最基础的SVM了，我们进行小结：<br>要实现分类，就要使得两类数据之间差距尽量大，所以我们目标最大化间隔。写出公式进行推导，我们要做的就是：$$min(\frac{1}{2}||w||^2),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1$$我们要解决这个带不等式约束的最优化问题，我们引入拉格朗日对偶，将原函数对偶为拉格朗日函数，再利用KKT条件，进行求解。</p><h2 id="如何使SVM分类更好"><a href="#如何使SVM分类更好" class="headerlink" title="如何使SVM分类更好"></a>如何使SVM分类更好</h2><p>在实际问题当中，并非都是理想的数据，少不了噪声。</p><p>总会有异常值：<br><img src="/images/Pasted image 20241206185529.png" style="zoom:200%;"/><br>我们需不需要为了这个异常值牺牲掉我们的间隔距离呢？<br>我们进行分析，如果我们考虑这个异常值，决策超平面就是上图中的实线，如果我们忽略这个异常点，决策超平面就是上图中的虚线。显然虚线的间隔大于实线的间隔，虚线分类的效果要好于实线。这样看来，我们应当牺牲到这个异常值。</p><p>但是，有更多的异常值的时候怎么办呢？不能全都不考虑吧？或者，数据本身就线性不可分呢？<br><img src="/images/Pasted image 20241206185136.png" style="zoom:200%;"/><br>显然，上图是找不到一个完美的直线将两类数据全部分开，此时我们怎么办呢？</p><h3 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h3><p>我们提出软间隔来解决这个问题。<br>硬间隔是指支持向量机在训练过程中要求数据必须完全线性可分，并且找到一个超平面，使得两类样本点与该超平面之间的距离（即间隔）最大。<br>软间隔是为了处理线性不可分的情况而引入的概念。在软间隔中，允许一些点位于错误的边界一侧，即允许出现少量的分类错误。<br><img src="/images/Pasted image 20241202151002.png" style="zoom:200%;"/></p><p>理解软间隔，我们可以将其类比为做生意。<br><img src="/images/Pasted image 20241202150858.png" style="zoom:200%;"/><br>间隔类比为收入，异常值造成的错误类比为成本，我们同时考虑收入和成本，将我们的利益最大化。这个最优解下形成的间隔我们称为软间隔，有一定的容错率，目的是在间隔距离和错误大小间找到一个平衡。</p><p>软间隔允许某些数据点位于分割超平面的错误一侧（即存在一定程度上的误分类）。但是，对于误分类的点，会给予一定程度的惩罚，这避免让这些错误对模型的整体性能影响过大。</p><p>怎样去量化我们的成本呢？下图是一个形象的解释。<br><img src="/images/Pasted image 20241203100342.png" style="zoom:200%;"/><br>软间隔通过引入一个松弛变量来度量每个点偏离间隔的程度，也就是通过松弛变量来量化了误差。<br><img src="/images/Pasted image 20241218162850.png" style="zoom:200%;"/><br>我们就是要在考虑最小化这个误差​$$min(\sum_{i&#x3D;1}^{n} \xi_i)$$并且使得间距最大。$$min(\frac{1}{2}||w||^2),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1$$<br>整合为：$$min(\frac{1}{2}||w||^2+\sum_{i&#x3D;1}^{n} \xi_i),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1-\xi_i$$在这个基础上，我们再引入惩罚参数C，表达我们对误分类的容忍度。$$min(\frac{1}{2}||w||^2+C\sum_{i&#x3D;1}^{n} \xi_i),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1-\xi_i\quad \text{ }\xi_i\geq0$$其中需要提醒：C&gt;&#x3D;0，ξ&#x3D;max(0，1-y*(wx+b))。<br>对于ξ，若正确分类则ξ&#x3D;0，若错误分类则ξ&#x3D;1-y*(wx+b)</p><p>这样，我们调节C就能够调节模型对误分类的容忍程度。<br>C越大，惩罚越大，容忍程度越小，越不容易误分类，这样的话间距就较小，极端情况下就等于硬间隔。<br>C越小，惩罚越小，容忍程度越大，越容易误分类，这样的话间距就较大。<br><img src="/images/Pasted image 20241203101442.png" style="zoom:200%;"/></p><p>对于不同大小惩罚参数C的设置，下面这张图能有一个直观的体现：<br><img src="/images/Pasted image 20241203104156.png" style="zoom:200%;"/><br>这个惩罚参数C对软间隔非常重要，选择合适的C，效果是完全不一样的。</p><h3 id="维度转换"><a href="#维度转换" class="headerlink" title="维度转换"></a>维度转换</h3><p>加入了软间隔，SVM的线性分隔已经能分得不错了，但是只能线性。而实际问题当中，肯定不完全是线性的分类。对于非线性的数据，我们应当怎么办呢？</p><p>就比如下面这个例子<br><img src="/images/92717e5f99119afd65e358694b6f366.jpg" style="zoom:200%;"/><br>这组数据感觉上是没办法用线性来分类的，需要一个曲线。<br>但是我们将这个二维数据放到三维来看，令人惊讶的是，这个看似不能线性分类的数据竟然在三维当中非常容易地能够被线性超平面完美的分开！</p><p>受此启发，我们在面对线性不可分的情况，完全可以提高维度来看这个问题。</p><p>我们可以通过合适的维度转化函数，将低纬数据进行升维。在高纬度下求解SVM模型，找到对应的分割超平面。</p><p>当有新数据需要进行分析预测时，可以对其先做升维转换操作，在根据高纬度下的决策边界超平面进行判断。<br><img src="/images/QQ_1734435124591.png" style="zoom:200%;"/><br>我们要实现这个提升维度逻辑，我们需要明确的维度转换函数，以及更多的数据存储，计算需求。这是一个十分麻烦的事，尤其是数据存储，困难非常大。</p><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><p>有什么办法能够避免将数据送入高纬度进行计算，却又能获得同样的分类效果呢？<br>我们就需要运用<mark>核技巧(Kernel Trick)</mark><br>回想我们的目标：</p><p>$$min(\frac{1}{2}||w||^2+C\sum_{i&#x3D;1}^{n} \xi_i),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1-\xi_i\quad \text{ }\xi_i\geq0$$</p><p>我们可以将它转化为拉格朗日对偶问题：<br>$$L(w,b,ξ_i,α_i,β_i)&#x3D; \frac{1}{2} ||w||^2 + C \sum_{i&#x3D;1}^{n} ξ_i - \sum_{i&#x3D;1}^{n} α_i ( y_i (w^T x_i + b) - 1 + ξ_i ) - \sum_{i&#x3D;1}^{n} β_i ξ_i$$</p><p>我们分别求偏导：<br><img src="/images/Pasted image 20241217214334.png" style="zoom:200%;"/><br>我们将w和b代入原始的代入原始的拉格朗日函数，消去变量，我们就拿到对偶问题：最大化拉格朗日乘子α（二分之一后面那一堆其实为0）：<br>$$max(\sum_{i&#x3D;1}^nα_i-\frac{1}{2} \sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{n} \alpha_i \alpha_j y_i y_jx_{i}^Tx_j)\quad \text{s.t.  } α_i\geq0，\beta_i\geq0，\sum_{i&#x3D;1}^{n}α_iy_i&#x3D;0，C-α_i-\beta_i&#x3D;0$$</p><p>四个约束条件可以简化为两个：$$\sum_{i&#x3D;1}^{n}α_iy_i&#x3D;0，0\leq α_i \leq C$$</p><p>又将最大化转化为最小化，原始问题的对偶问题就变成了：<br>$$\min_{\alpha_i}(\frac{1}{2} \sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{n}α_iα_jy_iy_jx_{i}^Tx_j-\sum_{i&#x3D;1}^{n}α_i)\quad \text{s.t.  } \sum_{i&#x3D;1}^{n}α_iy_i&#x3D;0，0\leq α_i \leq C$$<br>仔细观察这个式子，当中有<br>$$x_i^Tx_j$$<br>我们升维之后：<br>$$x_i\quad——&gt;\quad T(x_i)$$<br>那我们需要的其实就是：$$T(x_i^T)T(x_i)$$<br>我们就将这个东西称作核函数：</p><p>$$T(x_i^T)T(x_i)&#x3D;K(\vec{x_i},\vec{x_i})$$<br>选取合适的核函数，我们就能够不同知晓具体的维度转化函数而直接获取点积，运用到式子当中。其实核函数起到的作用就是测量高维向量相似度，直接获得数据的高维差异度，以此为依据来进行分类判断。<br><img src="/images/Pasted image 20241217220726.png" style="zoom:200%;"/></p><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><p>我们讨论两种核函数：<br>多项式核函数和高斯核函数。</p><h5 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h5><p>$$<br>K(\mathbf{x}, \mathbf{x}’) &#x3D; (\mathbf{x}^T \mathbf{x}’ + c)^d<br>$$<br>多项式核函数中的常数项参数c非常重要，因为c存在，最终点积结果的表达式中才包含了从低次项到高次项的数据组合，体现出维度的多样性。缺少常数项的话，表达式中只会包含包括高次项。但是对于无常数项参数c的多项式核函数来说，我们也可以将多个不同次的多项式核函数相加组合，使其结果同时具有高低次项，以此丰富维度的多样性。</p><h5 id="高斯核函数-RBF"><a href="#高斯核函数-RBF" class="headerlink" title="高斯核函数(RBF)"></a>高斯核函数(RBF)</h5><p>$$<br>K(\mathbf{x}, \mathbf{x}’) &#x3D; e^  {- \gamma |\mathbf{x} - \mathbf{x}’|^2 }<br>$$<br>对这个函数进行数学转化!<img src="/images/Pasted image 20241202235247.png" style="zoom:200%;"/><br>其中使用<mark>泰勒展开</mark>，最后这个式子代表，不带常数项c的多项式核函数从低次到无穷高次依次排列，根据不同阶乘系数调整后再相加。<br>结合上面的多项式核函数，我们知道这样的式子能够体现出<mark>无限维度</mark>数据高低次项组合无限多样性的特点。我们就实现了在不实质性踏入无限维度的情况下，得到了无限维度下的向量相似度的结果。<br>总结来说，高斯核函数隐式地将数据点映射到一个 <strong>无限维</strong> 的空间，计算样本点之间的相似度。通过 RBF 核，我们能够隐式地计算高维空间中的内积，它的值反应了<mark>两向量的相似度大小</mark>。</p><p>在高斯核函数当中，γ是一个大于0的值，当γ值确定，两点距离越大，其相似度越向0靠近，距离越小，相似度越向1靠近；γ值越小，图像越扁平，繁殖越尖锐。扁平和尖窄，决定了高斯核函数相对相似度的判断标准。对这个函数进行数学转化!<img src="/images/Pasted image 20241217223425.png" style="zoom:200%;"/><br>这个γ值是我们自己决定的，是一个可控的重要参数。我们放到分类问题当中来</p><ol><li>小γ值的情况下，数据点间的相似度被放大了，就很容易认为两个数据点是一类。</li><li>大γ值的情况下，除了距离非常近的数据点以外，其余数据点均与其他店缺乏相似性。也就是说判定两个数据点是一类的更严苛。值越大，条件越严苛，严苛的条件往往会导致过拟合问题。我们放张图来理解：<img src="/images/Pasted image 20241217223904.png" style="zoom:200%;"/></li></ol><h5 id="两种核函数的比较"><a href="#两种核函数的比较" class="headerlink" title="两种核函数的比较"></a>两种核函数的比较</h5><p>多数情况下，高斯核函数的效果要优于多项式核函数。<br><img src="/images/Pasted image 20241203110706.png" style="zoom:200%;"/></p><h5 id="核函数和核技巧"><a href="#核函数和核技巧" class="headerlink" title="核函数和核技巧"></a>核函数和核技巧</h5><p>通过 <strong>核函数</strong> 我们能够计算高维点积，<strong>而不需要显式地知道映射到高维空间的特征函数</strong>。这个过程被称为 <strong>核技巧（Kernel Trick）</strong></p><h2 id="SM0简述（序列最小最优化算法）"><a href="#SM0简述（序列最小最优化算法）" class="headerlink" title="SM0简述（序列最小最优化算法）"></a>SM0简述（序列最小最优化算法）</h2><p>核函数那里，我们从$$min(\frac{1}{2}||w||^2+C\sum_{i&#x3D;1}^{n} \xi_i),\quad \text{s.t.  } (w^T x^i + b)y^i&gt;&#x3D;1-\xi_i\quad \text{ }\xi_i\geq0$$推到了$$\min_{\alpha_i}(\frac{1}{2} \sum_{i&#x3D;1}^{n} \sum_{j&#x3D;1}^{n}α_iα_jy_iy_jx_{i}^Tx_j-\sum_{i&#x3D;1}^{n}α_i)\quad \text{s.t.  } \sum_{i&#x3D;1}^{n}α_iy_i&#x3D;0，0\leq α_i \leq C$$我们的变量变成了α，一个α对应了一个(x,y)。那我们变量的总数等于训练样本的总数。这个优化涉及到大量的变量，特别是在处理大规模数据时，直接求解会非常耗时。</p><p>我们提一提<mark>坐标上升法</mark><br>坐标上升法每次只优化一个变量(坐标)，而不是同时更新所有变量（梯度下降）。在每一步中，固定其他所有变量，只更新一个变量，直到收敛或达到预定的停止条件。![[Pasted image 20241218151722.png]]<br>通过上图来理解，单独优化α1，α2……αn，一步一步地走到函数的极值。</p><p>对于我们的SVM能够使用这个方法吗？<br>别忘了我们有一个限制条件$$\sum_{i&#x3D;1}^{n}α_iy_i&#x3D;0$$我们要是选择一个α进行优化而将其他α当做常数的话，意味着有一个α不断改变其他α不变。这样是肯定做不到和为0的，也就不满足我们的限制条件。</p><p>SMO怎么做的呢？SMO选择两个α进行优化，来保持平衡，使得和为0。<br>而两个参数的变化也能够通过下面的推导变成一个参数的变化。<br><img src="/images/Pasted image 20241218153525.png" style="zoom:200%;"/></p><p>剩下的就是一步又一步的循环了。</p><p>序列最小优化算法的核心优势在于：相较于同时处理大规模变量，更新两个变量十分高效(虽然需要重复很多次)</p><p>SMO是一个非常有趣的算法，还有许多令人兴奋的精妙点，在此不做详细介绍。</p><p>总结来说：SMO通过分解变量众多的问题，将其转化为一个较小规模的额二次规划问题，进而逐步解决。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>SVM曾经何等风光，如今在深度学习的浪潮之下，也有了SVM过时的声音。私以为，学习这件事，可以任性些，觉得有意思就学。少些功利，快乐自会降临。</p><hr><br>lc留言：lu加油!   <img src="/images/00822FC2.png"/><br><hr><p>感谢这些视频和文章对我的指导：<br><a href="https://www.bilibili.com/video/BV16T4y1y7qj/?spm_id_from=333.337.search-card.all.click&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV16T4y1y7qj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV13r4y1z7AG/?spm_id_from=333.337.search-card.all.click&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV13r4y1z7AG/?spm_id_from=333.337.search-card.all.click&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1Nb4y1s7pE?spm_id_from=333.788.videopod.sections&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV1Nb4y1s7pE?spm_id_from=333.788.videopod.sections&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1AS4y1K7Jf?spm_id_from=333.788.videopod.sections&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV1AS4y1K7Jf?spm_id_from=333.788.videopod.sections&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1xB4y127cs?spm_id_from=333.788.videopod.sections&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV1xB4y127cs?spm_id_from=333.788.videopod.sections&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1kJ411g7jg?spm_id_from=333.788.videopod.episodes&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e&p=13">https://www.bilibili.com/video/BV1kJ411g7jg?spm_id_from=333.788.videopod.episodes&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e&amp;p=13</a><br><a href="https://www.bilibili.com/video/BV1kJ411g7jg?spm_id_from=333.788.videopod.episodes&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e&p=14">https://www.bilibili.com/video/BV1kJ411g7jg?spm_id_from=333.788.videopod.episodes&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e&amp;p=14</a><br><a href="https://www.bilibili.com/video/BV15T411f7DY/?spm_id_from=333.337.search-card.all.click&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV15T411f7DY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1rS4y1p7w7?spm_id_from=333.788.videopod.sections&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV1rS4y1p7w7?spm_id_from=333.788.videopod.sections&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.bilibili.com/video/BV1kf4y1o793?spm_id_from=333.788.videopod.sections&vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e">https://www.bilibili.com/video/BV1kf4y1o793?spm_id_from=333.788.videopod.sections&amp;vd_source=323275cc1c2c3b2b32c7afd4ccdbb86e</a><br><a href="https://www.cnblogs.com/xinchen1111/p/8804858.html">https://www.cnblogs.com/xinchen1111/p/8804858.html</a><br>统计学习方法(第二版)第7章支持向量机    ——李航<br>动手学机器学习11.2最小序列优化              ——张伟楠，赵寒烨，俞勇</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类 </tag>
            
            <tag> 支持向量机 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Means++</title>
      <link href="/2024/11/04/K-Means++/"/>
      <url>/2024/11/04/K-Means++/</url>
      
        <content type="html"><![CDATA[<h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means++"></a>K-Means++</h1><h2 id="什么是k-means"><a href="#什么是k-means" class="headerlink" title="什么是k-means++"></a>什么是k-means++</h2><p><strong>K-means++</strong> 是一种改进的质心初始化方法，用来解决 K-means 聚类算法对初始质心敏感的问题。通过 K-means++ 的初始化方式，可以使 K-means 更加稳定、快速地收敛，同时提高找到全局最优解的可能性。</p><h2 id="k-means-的主要思想"><a href="#k-means-的主要思想" class="headerlink" title="k-means++的主要思想"></a>k-means++的主要思想</h2><p>在选择灭一个新的初始质心时，<mark>优先选择离已有质心较远的点</mark>，这样可以确保初始质心尽量分散，覆盖数据的主要区域，从而减少迭代次数，降低陷入局部最优解的可能性。</p><h2 id="为什么k-means-有效"><a href="#为什么k-means-有效" class="headerlink" title="为什么k-means++有效"></a>为什么k-means++有效</h2><p>首先可以看一组对比图：<br>![[output.png]]</p><ol><li>减少了局部最优的风险：K-means 的随机初始化容易导致质心集中在数据的某个局部区域，导致算法陷入局部最优。K-means++ 通过让质心分散，从而增加找到全局最优解的可能性。</li><li>加速收敛：初始质心更合理时，数据点会更接近其正确的簇，减少了算法调整质心位置的工作量，从而加快收敛。</li><li>平衡簇的大小：通过选择离现有质心较远的数据点作为新的质心，K-means++ 在初始化时就确保簇分布较均匀，避免出现某些簇过大或过小的情况。</li></ol><h2 id="k-means-的步骤"><a href="#k-means-的步骤" class="headerlink" title="k-means++的步骤"></a>k-means++的步骤</h2><ol><li>随机选择第一个质心：从数据集中选择一个数据点作为第一个质心。</li><li>计算每个数据点到最近质心的距离记为D(x)。同k-means，这篇文章当中有讲到这一点[[机器学习之聚类算法]]</li><li>概率选择下一个质心<ol><li>选择下一个质心时，不是完全随机选择，而是根据距离的平方来确定选择的概率。</li><li>将每个数据点x以D(x)的平方作为概率选择为下一个质心，具体来说，距离越远的点有更高的概率被选为新的质心。</li></ol></li><li>重复2和3，直到选择了K个质心。</li><li>开始标准的K-means迭代：使用初始化得到的K个质心，按照标准的K-means算法进行迭代，直到算法收敛。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里实现最关键的<mark>确定质心</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_centroids_kmeans_pp</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 K-means++ 方法初始化质心.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    - X: 数据集 (numpy array)，形状为 (n_samples, n_features)</span></span><br><span class="line"><span class="string">    - K: 需要生成的簇数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    - centroids: 初始化的 K 个质心，形状为 (K, n_features)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取样本数和特征数</span></span><br><span class="line">    n_samples, n_features = X.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个空的质心数组</span></span><br><span class="line">    centroids = np.zeros((K, n_features))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机选择第一个质心</span></span><br><span class="line">    centroids[<span class="number">0</span>] = X[np.random.randint(<span class="number">0</span>, n_samples)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择接下来的质心</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">        <span class="comment"># 计算每个数据点到最近已选质心的距离平方</span></span><br><span class="line">        distances = np.<span class="built_in">min</span>([np.linalg.norm(X - centroid, axis=<span class="number">1</span>)**<span class="number">2</span> <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids[:i]], axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 依据距离平方，按比例选择下一个质心</span></span><br><span class="line">        probabilities = distances / distances.<span class="built_in">sum</span>()</span><br><span class="line">        cumulative_probabilities = np.cumsum(probabilities)</span><br><span class="line">        r = np.random.rand()</span><br><span class="line">        next_centroid_idx = np.where(cumulative_probabilities &gt;= r)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将选中的数据点作为下一个质心</span></span><br><span class="line">        centroids[i] = X[next_centroid_idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之聚类算法基础</title>
      <link href="/2024/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="什么是聚类"><a href="#什么是聚类" class="headerlink" title="什么是聚类"></a>什么是聚类</h2><blockquote><p>一个班级很多人，随着时间的推移，会形成几个小团体，这个找朋友的过程就叫做聚类。人以类聚，物以群分，数据亦如此。</p></blockquote><blockquote><p>聚类是最常见的无监督学习算法，把一个数据集按照某个特定标准(比如距离)分割成不同类或簇，使得同一个簇内的数据相似性尽可能大，不同簇差异尽可能大<br><img src="/images/Pasted image 20241103201908.png" style="zoom:200%;"/></p></blockquote><h2 id="有哪些聚类"><a href="#有哪些聚类" class="headerlink" title="有哪些聚类"></a>有哪些聚类</h2><p>找朋友肯定要有一定的标准吧，比如我是柯哀党，你是新兰党，肯定是水火不容不能分为一类的。根据不同分割标准，我们有很多种的聚类算法，下图陈列了一些。<br><img src="/images/Pasted image 20241103203619.png" style="zoom:200%;"/></p><h2 id="怎样实现聚类"><a href="#怎样实现聚类" class="headerlink" title="怎样实现聚类"></a>怎样实现聚类</h2><h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p><mark>k-means是基于划分的聚类</mark></p><h5 id="质心"><a href="#质心" class="headerlink" title="质心"></a>质心</h5><p>一个团体总有一个核心，比如中国共产党代表全国人民最根本的利益，所有人民都围绕着中国共产党。数据也有一个聚类中心，一类数据(一个簇)会围绕着一个聚类中心。我们将这个聚类中心称作<strong>质心</strong>，我们用μ来表示。<br>$$μ_i &#x3D; \frac{1}{|C_i|}\sum_{x \in C_i} x$$<br>(第i个簇的质心μ是该簇内所有数据点的平均值，也就是中心点)</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>要评价类分得好不好，我们自然要引进损失函数，也称失真函数。<br>$$J(c^{(1)},…c^{(m)}, \mu_1,…\mu_K) &#x3D; \frac{1}{m}||x^{(i)} - \mu_c^{(i)}||^2$$<br>失真函数是表现的簇内点到簇中心的距离平方。距离越远，说明这个团队不够紧密，也就说明这个类聚得不好。<br><img src="/images/Pasted image 20241104172257.png" style="zoom:200%;"/></p><p>我们要使得距离近有什么办法呢？</p><ul><li><p>第一点，每个样本点划分到最近的中心点队列。（群众要紧紧拥护党的领导）</p><blockquote><p>众多的簇内点应该选取合适的簇中心。如下图，x距离红色质心的距离会远小于蓝色质心的距离。<br><img src="/images/Pasted image 20241103125055.png" style="zoom:200%;"/></p></blockquote></li><li><p>第二点，质心应该应该到合适的地方。（党应该深入人民群众）</p><blockquote><p>质心要到中心去，这样总体的距离之和才会小。这是一个数学问题，本质上是高中均值不等式当中的平方均值不等式。<br>$$\frac{a + b}{2} \geq \sqrt{\frac{a^2 + b^2}{2}}  （a&#x3D;b时等号成立）$$<br><img src="/images/Pasted image 20241103125128.png" style="zoom:200%;"/><br>显然有a+b&#x3D;10，那么有<br><img src="/images/Pasted image 20241104164538.png" style="zoom:200%;"/><br>也就是说取均值时，距离平方和最小。所以我们应该算取每个类别中样本点的均值，将均值作为新的中心点。<br><img src="/images/Pasted image 20241104172908.png" style="zoom:200%;"/></p></blockquote></li></ul><p>要实现下来，总共就两步：将样本点分配给最近的质心，根据分配重新计算质心。<br>K-means关键就是这两步，一次一次迭代，最终就能聚类。</p><p>还需要注意的是：</p><ol><li>初始化质心<blockquote><p>最开始是没有质心的，也就没有办法进行分配，所以我们应该初始化质心。怎么初始化，可以取随机的样本点。</p></blockquote></li></ol><blockquote><p>K-Means的质心特别重要，十分敏感。如果最开始的质心没有被分配点，那么求平均值是没有意义的。最常见的做法是消除没有点集群，得到k-1个簇。<br><img src="/images/Pasted image 20241104173001.png" style="zoom:200%;"/><br>我们可以使用K-means++，详情可以参考<a href="https://sorcerer.zeabur.app/2024/11/04/K-Means++/" target="_blank">K-Means++</a></p></blockquote><ol start="2"><li>选择合适的K值（也就是合适的质心数量）<blockquote><p>K值选择不当，会造成过拟合或欠拟合。我们常常选择“肘部法”。<br><img src="/images/Pasted image 20241103132931.png" style="zoom:200%;"/><br>有一个值，过了这个值，损失函数下降的幅度比较小，这个就是我们需要的K。<br>值得一提的是，选择K值并不完全根据损失来定，我们要结合实际情况。</p></blockquote></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>代码实现迭代的k-means的关键两步：</p><ol><li>将样本点分配给最近的质心：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_closest_centroids</span>(<span class="params">X, centroids</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    计算每个实例的质心隶属度  </span></span><br><span class="line"><span class="string">    :param X: 形状为(m,n)的numpy数组，其中m是样本数量，n是特征数量。X中包含了m个数据点，每个数据点有n个特征  </span></span><br><span class="line"><span class="string">    :param centroids: 形状为(k,n)的numpy数组，k是质心的数量，每个质心也有n个特征  </span></span><br><span class="line"><span class="string">    :return: 一个形为(m,)的数组，表示每个数据点最近的质心的索引  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="comment"># 获取centroids的第一维度，就是获取质心的数量K </span></span><br><span class="line">    K = centroids.shape[<span class="number">0</span>]   </span><br><span class="line">    <span class="comment"># 创建一个全零的数组idx，长度为m，用于存储每个数据点最近的质心的索引  </span></span><br><span class="line">    idx = np.zeros(X.shape[<span class="number">0</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]): <span class="comment"># 每个实例  </span></span><br><span class="line">        distance = []  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(K): <span class="comment"># 每个质心  </span></span><br><span class="line">        <span class="comment"># 欧几里得距离来进行计算距离  </span></span><br><span class="line">            norm_ij = np.linalg.norm(X[i] - centroids[j]) </span><br><span class="line">            distance.append(norm_ij)  </span><br><span class="line">        <span class="comment"># 找到最近质心的索引  </span></span><br><span class="line">        idx[i] = np.argmin(distance)    </span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure></li><li>使用分配给每个质心的点重新计算平均值: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_centroids</span>(<span class="params">X, idx, K</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    用于计算新的质心，分配给每个质心的数据点的平均值  </span></span><br><span class="line"><span class="string">    :param X::param idx::param K::return:   </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    m, n = X.shape  </span><br><span class="line">    <span class="comment"># 创建一个形状为(K,n)的numpy数组，用来存储计算得到的新质心  </span></span><br><span class="line">    centroids = np.zeros((K, n))    </span><br><span class="line">    <span class="comment"># 计算新质心  </span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K):  </span><br><span class="line">    <span class="comment"># 找到所有分配给当前质心k的数据点  </span></span><br><span class="line">        points_assigned_to_k = X[idx == k]  </span><br><span class="line">        <span class="keyword">if</span> points_assigned_to_k.size &gt; <span class="number">0</span>:   <span class="comment"># 确保有点被分配  </span></span><br><span class="line">            centroids[k] = np.mean(points_assigned_to_k, axis=<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure></li></ol><h3 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h3><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p><mark>谱聚类是基于图的聚类</mark></p><p>聚类可以理解为：让距离更近的样本聚集在一起，距离远的样本分到不同的簇中。<br>我们可以用权重来表示距离大小(相似性)。那么聚类的过程就可以说成把数据集切开，切成需要的份数，最终的结果就是每个子集里面的样本呢权重尽可能大，子集之间被切断的权重尽可能小。那么聚类的关键问题就是：<mark>我们应该怎么去切这个数据集？</mark>而谱聚类的关注点就是解决这个问题。</p><h5 id="谱聚类的整体步骤"><a href="#谱聚类的整体步骤" class="headerlink" title="谱聚类的整体步骤"></a>谱聚类的整体步骤</h5><ol><li>基于已有的数据集进行构图</li><li>基于构好的图进行切图</li></ol><h5 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h5><p>我们要进行构图，要构造什么样的图呢？<br>介绍一些索然无味的概念。</p><blockquote><p>对于一个图G，我们通常描述为G(V,E)  其中的V是点的集合(也就是我们的数据集)，E是边的集合。我们定义两个点之间的权重为w，由于是无向图w_ij &#x3D; w_ji 。 有连接的两个点w&gt;0，没有连接的两个点，w&#x3D;0。</p></blockquote><blockquote><p>对于任意一个点，我们给它定义一个度（d_i），一个点的度就是这个点和它相连的所有点的权重之和。$$ d_i &#x3D; \sum_{j&#x3D;1}^{n} w_{ij} $$<br>我们再在度这个概念之上，定义一个度矩阵，度矩阵是一个n阶主对角方阵，n就是图中标的节点数。<br>$$D &#x3D; \begin{pmatrix}<br>d_1 &amp; 0 &amp; \cdots &amp; 0 \<br>0 &amp; d_2 &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; \cdots &amp; d_n \<br>\end{pmatrix}$$<br>有两个令人好奇的点，一是这个矩阵为什么要定义成方阵呢？二是为什么只有主对角线上有数据呢？<br>为什么是方阵？这是一个很有趣的问题，但是答案很无趣，因为定义。只是为了将矩阵的维度与节点的数量进行匹配。<br>为什么只有主对角线上有数据？因为度只跟该节点本身有关，不涉及节点之间的具体连接关系。非对角线上的0表示节点之间没有直接的联系。</p></blockquote><blockquote><p> 一个图我们已经有点集合了，那关键的就是边，也就是权重，我们把所有样本点的权重组成的矩阵，称之为邻接矩阵W，邻接矩阵也是一个n阶方阵。<br> $$<br>W &#x3D; \begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{bmatrix}<br>$$<br> 构建邻接矩阵方法主要有三种：  ϵ-邻近法，K邻近法、全连接法</p></blockquote><p>我们讨论一些这三种方法：</p><ol><li>ϵ-邻近法<br> s_ij是点i和点j之间的欧氏距离，我们提出一个距离阈值ϵ。我们来定义邻接矩阵：$$<br>w_{ij} &#x3D;<br>\begin{cases}<br>0, &amp; \text{if } s_{ij} &gt; \epsilon \<br>\epsilon, &amp; \text{if } s_{ij} \leq \epsilon<br>\end{cases}<br>$$<br> 这样邻接矩阵只有两种数据，表达的也只是有边还是没边。<br> 比如： $$<br>W &#x3D; \begin{bmatrix}<br>0 &amp; 1 &amp; \cdots &amp; 1 \<br>1 &amp; 0 &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 1 &amp; \cdots &amp; 0<br>\end{bmatrix}<br>$$<br> 其中a_12表示节点1和节点2有边(有联系)，若为0则表示没边。<br> 这个方法的话表示距离远近就很不理想。</li><li>K邻近法<br> 利用遍历所有的样本点，取每个样本最近的k个点作为近邻，只有和样本距离最近的k个点之间有权重w&gt;0。<img src="/images/Pasted image 20241104194640.png" style="zoom:200%;"/></li><li>全连接法<br> $$<br>w_{ij} &#x3D; s_{ij} &#x3D; \exp\left(-\frac{||x_i - x_j||^2}{2\sigma^2}\right)<br>$$<br>全连接法是建立邻接矩阵最普遍的方法。</li></ol><p>构图方面，我们再提及一个<mark>拉普拉斯矩阵</mark>(L)<br>其实非常简单：L &#x3D; D - W</p><h6 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h6><p>我们的目标是将图G(V,E)切成相互没有连接的多个子图。</p><p>针对任意两个子图点的集合A,B⊂V，A∩B&#x3D;∅，我们提出切图权重：$$<br>W(A, B) &#x3D; \sum_{i \in A, j \in B} w_{ij}<br>$$<br>明显的，切图权重表达的是1图中的所有点，和2图中的所有点，两两权重之和。<br>如果这个切图权重大，就说明两个图中的点联系紧密，说明切得不好。</p><p>我们针对所有的子图（假设一共有m个）它们图中的点集是A_1, A_2……A_m，我们定义cut：<br>$$<br>cut(A_1, A_2, \ldots, A_m) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} W(A_i, \overline{A_i})<br>$$<br>这个式子表现了所有子图图之间的权重，最小化cut，那就使得子图联系最小，达成了切图。切成了一个又一个联系小甚至没有联系的子图。</p><img src="/images/Pasted image 20241104201735.png" style="zoom:200%;"/><p>如何去使得这个cut最小？我们提出两种切图方法：<br>RatioCut切图和Ncut切图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode76(最小覆盖子串)</title>
      <link href="/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/"/>
      <url>/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-最小覆盖子串"><a href="#滑动窗口-最小覆盖子串" class="headerlink" title="滑动窗口(最小覆盖子串)"></a>滑动窗口(最小覆盖子串)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode76.png" alt="26" style="zoom:50%;" align="left"/><img src="/images/leetcode76.jpg" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>窗口中频率达到要求的字母数量&#x3D;t中的字母种量，就表明我们找到一个子串，但不一定是最小子串。<code>required == formed</code>。用两个数组来记录频率，巧妙地将ASCII码当做下标，使得字母和频率一一对应。<code>int tFreq[128] = &#123;0&#125;, windowFreq[128] = &#123;0&#125;;</code>。这个过程是<strong>扩展右边界</strong>的过程。</p></blockquote><blockquote><p>当找到一个子串时，我们就应该寻找下一个子串，这个时候就应收缩窗口，移动左边界。顺带长度。收缩之后，有可能减少的那个就是我们需要的那个，我们要检查一下满足的数量<code>formed</code>是否减少。这个过程就是<strong>收缩左边界的过程</strong>。</p></blockquote><blockquote><p>我在<code>left &lt; right</code>还是<code>left &lt;= right</code>这一点犯了一些迷糊。答案显然是后者，因为当<code>left == right</code>的时候，说明这个字符串只有一个字母，难道只有一个字母就不去检查更新了吗，肯定不对啊。随意这个时候还是应当进入循环，所以选择<code>&lt;=</code>。</p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">minWindow</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> window_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;, t_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> required = <span class="number">0</span>, formed = <span class="number">0</span>, start = <span class="number">0</span>, min_len = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计t中每个字符出现的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; t[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t_freq[t[i]] == <span class="number">0</span>) required++;</span><br><span class="line">t_freq[t[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line"><span class="type">char</span> ch = s[right];</span><br><span class="line">whidow_freq[ch]++;</span><br><span class="line"><span class="keyword">if</span>(t_freq[ch] &gt; <span class="number">0</span> &amp;&amp; window_freq[ch] == t_freq[ch]) formed++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; formed == required)&#123;</span><br><span class="line"><span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; min_len)&#123;</span><br><span class="line">min_len = right - left + <span class="number">1</span>;</span><br><span class="line">start = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除左边字符并且更新窗口状态</span></span><br><span class="line"><span class="type">char</span> left_char = s[left];</span><br><span class="line">widow_freq[left_char]--;</span><br><span class="line"><span class="keyword">if</span>(t_freqp[left_char] &gt; <span class="number">0</span> </span><br><span class="line">&amp;&amp; window_freq[letf_char] &lt; t_freq[letf_char]) formed--;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min_len == INT_MAX) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* result = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(min_len+<span class="number">1</span>));</span><br><span class="line">result[min_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题感觉很难，但本质上是滑动窗口，对比分析一下基础的滑动窗口<a href="https://sorcerer.zeabur.app/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/" target="_blank">滑动窗口leetcode209(长度最小的子数组)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode904(水果成篮)</title>
      <link href="/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/"/>
      <url>/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-水果成篮"><a href="#滑动窗口-水果成篮" class="headerlink" title="滑动窗口(水果成篮)"></a>滑动窗口(水果成篮)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode904.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>扩大和缩小</p></blockquote><p>如果满足要求，那就扩大右边界<br>如果不满足要求，就缩小左边界</p><p>怎么判断是否满足要求呢？种类数量，实现方法是用一个数组来存放每种水果放在篮子里的数量</p><p>同样存在while和if的选择，缩小时采用的是while，原因左边可能存在连续的并且内容一致的，要一直缩小到满足条件。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>* fruits, <span class="type">int</span> fruitsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> basket[<span class="number">100001</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录每种水果的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_num = <span class="number">0</span>, unique_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; fruitsSize)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被放入篮子，就将它添加到篮子中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(basket[fruits[right]] == <span class="number">0</span>) unique_num++;</span><br><span class="line"></span><br><span class="line">        basket[fruits[right]]++;</span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//当篮子中水果种类超过2时，移动左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(unique_num &gt; <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">            basket[fruits[left]]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(basket[fruits[left]] == <span class="number">0</span>) unique_num--;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新最大水果数量</span></span><br><span class="line"></span><br><span class="line">        max_num = (right - left &gt; max_num) ? (right - left) : max_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之逻辑回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h2><blockquote><p>逻辑回归是根据给定的数据集估算时间发生的概率，是一种分类</p></blockquote><blockquote><p>明明是分类为什么称作回归呢？<br>因为它的底层方法就是线性回归，逻辑回归是基于回归的伪回归算法。</p></blockquote><h2 id="实现基础的逻辑回归"><a href="#实现基础的逻辑回归" class="headerlink" title="实现基础的逻辑回归"></a>实现基础的逻辑回归</h2><h3 id="理解逻辑回归"><a href="#理解逻辑回归" class="headerlink" title="理解逻辑回归"></a>理解逻辑回归</h3><h4 id="逻辑函数的表达"><a href="#逻辑函数的表达" class="headerlink" title="逻辑函数的表达"></a>逻辑函数的表达</h4><p>回想线性方程<br>$$Z &#x3D; W^TX + b$$<br>对于直线，我们知道z的输出范围没有任何的限制，可以从负无穷到正无穷。但是，我们需要的是一个分类器，想要拿到两种结果，0或者1，所以我们需要输出范围为（0,1）的式子。<br>在线性方程的基础上达到规范输出范围这一目的，我们使用了Sigmoid函数$$σ(z) &#x3D; \frac{1}{1+e^{-z}}$$</p><img src="/images/Pasted image 20241028195414.png" style="zoom:200%;"/>图像很像s，就跟sigmoid沾上边了，所以拿到一个逻辑函数的名称。<p>我们在z的基础上进行的操作来达到控制范围的效果，我们就将z代入，就像下面这样。<br><img src="/images/Pasted image 20241028182720.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028190843.png" style="zoom:200%;"/><br>我们要明确最初的目标，是分类，只有两种结果，要么0要么1，那哪些判断为0哪些判断为1呢？<br>我们引入决策边界。边界内为一种情况，边界外为一种情况。<br>不难想到会有线性边界以及非线性边界<br>情况类似下图<br><img src="/images/Pasted image 20241028200239.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028183305.png" style="zoom:200%;"/></p><blockquote><p>所以，逻辑回归的整体思路是，先用逻辑函数把线性回归的结果 (-∞,∞)映射到(0,1)，再通过决策边界建立与分类的概率联系</p></blockquote><p>在二分类模型中，事件发生于不发生的概率之比$$\frac{p}{1-p}$$称作事件的几率。<br>几率的范围也是(0,1)，那我们就令<br>$$z &#x3D; log(\frac{p}{1-p})$$<br>也就是说，线性回归的结果等于对数几率。</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>自然，向线性回归一样，逻辑回归也需要我们判断拟合好与不好。</p><p>线性回归分析梯度下降时，我们就提出了，条条大路不一定都能通罗马，恰好线性回归的损失函数是一个碗罢了，只有一个最小。<br>那逻辑回归还会这么幸运吗？<br>并不是，逻辑函数的平方损失函数布满了局部最小值。<br><img src="/images/Pasted image 20241028183938.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028191058.png" style="zoom:200%;"/><br>这样一来，梯度下降难以实行啊。为了解决这个问题，我们得让它也像碗一样听话。</p><p>痛苦的根源是什么？有个e啊！还在分母上，怎么导也动不了啊！联想一下高考导数题，不难想到取对数。试一试，取对数情况很不错。</p><p>y要么为0要么为1，看一看对数的图像<br><img src="/images/Pasted image 20241028202156.png" style="zoom:200%;"/><br>如果是一根线，那么不管怎么个情况，0和1对应取到的值都是天壤之别。</p><p>一根不能满足，两根就可以。一正一负，很合适。看看下面三张图：<br><img src="/images/Pasted image 20241028185200.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028184731.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028185001.png" style="zoom:200%;"/></p><p>取对数，图形就变得很乖了，看不出坑坑洼洼。<br><img src="/images/Pasted image 20241028191229.png" style="zoom:200%;"/><br>这下就适合梯度下降了。</p><p>化简一下：<br><img src="/images/Pasted image 20241028192104.png" style="zoom:200%;"/></p><p>接下来就是线性回归一样的梯度下降处理了<br><img src="/images/Pasted image 20241028192602.png" style="zoom:200%;"/></p><p>不难看出，求的偏导跟线性回归好像一样。<br>但是区别就在于f的表达式。</p><p>剩下的处理跟线性回归也就大差不差了。详情可见<a href="https://sorcerer.zeabur.app/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" target="_blank">机器学习之逻辑回归基础</a></p><p><br><br><br><br><br>写在最后，感谢这些文章和视屏的指点：<br><a href="https://juejin.cn/post/7057447537757650957">https://juejin.cn/post/7057447537757650957</a><br><a href="https://blog.csdn.net/weixin_48524215/article/details/131350759">https://blog.csdn.net/weixin_48524215/article/details/131350759</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之线性回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h2 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h2><h3 id="什么是回归"><a href="#什么是回归" class="headerlink" title="什么是回归"></a>什么是回归</h3><blockquote><p>回归问题是函数拟合问题，就是给定一些点的集合，用一个曲线或者方程去拟合，使得所有点都大致符合</p></blockquote><h3 id="什么是线性回归-1"><a href="#什么是线性回归-1" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h3><blockquote><p>拟合的是一条直线，那就是线性回归</p></blockquote><h2 id="实现基础的线性回归"><a href="#实现基础的线性回归" class="headerlink" title="实现基础的线性回归"></a>实现基础的线性回归</h2><h3 id="实现回归的本质"><a href="#实现回归的本质" class="headerlink" title="实现回归的本质"></a>实现回归的本质</h3><p>拿到一个<em>好方程</em>，输入已知量(自变量)，就能通过这个方程预测未知量(我们想要的数据)</p><h3 id="拟合的方程"><a href="#拟合的方程" class="headerlink" title="拟合的方程"></a>拟合的方程</h3><p>我们假设能够拟合的方程是:<br>$$<br>h_\theta(x) &#x3D; \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \ldots + \theta_n x_n<br>$$<br>为了一般化这个方程，我们引入常量x0&#x3D;1<br>$$ h_\theta(x_{n\times1)} &#x3D; \sum_{i&#x3D;0}^{n} \theta_i \cdot x_i &#x3D;<br>\theta_{n\times1}^Tx_{1\times n}$$<br>要实现回归，就找到一群系数θ，也就是一个θ向量，也称作特征分量。</p><h3 id="拟合的好坏评价"><a href="#拟合的好坏评价" class="headerlink" title="拟合的好坏评价"></a>拟合的好坏评价</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>这个函数用来衡量我们预测值和真实值之间的差距<br>$$ J(\theta_{n\times1}) &#x3D; \frac{1}{2}\sum_{i&#x3D;1}^m(h_\theta(x_{n_\times1})^{(i)} - y^{(i)})^2$$</p><blockquote><p>(预测值-真实值)的平方，然后对每一组训练数据进行累加<br>需要一提的是，1&#x2F;2不是必要的，只是为了简化推导（最小二乘法的思想）</p></blockquote><p>损失函数的值小，就表明我们的误差小，那么我们的问题就变成了求最小值。<br>求$${minJ\theta}$$</p><h3 id="拟合的算法"><a href="#拟合的算法" class="headerlink" title="拟合的算法"></a>拟合的算法</h3><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><p>显然损失函数是一个关于θ的二次函数，二次函数的图像不外乎像这样：<br><br><img src="/images/Pasted image 20241028030501.png" style="zoom:200%;"/><br>导数为零的时候自然就是损失最小的时候<br>求损失函数关于θ的导数：<br>$$导数 &#x3D; 2{x^T_{n\times1}}(y_{n\times1} - x_{n\times1}\theta_{n\times1})$$<br>令导数为零，得到：<br>$$\theta_{n\times1} &#x3D; (x^T_{n\times1}x_{n\times1})^{-1}x^T_{n\times1}y_{n\times1}$$<br>也就是说代入这个公式，就能拿到合适的θ向量，也就达成了目标。<br>代码实现也不是很困难</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">standRegres</span>(<span class="params">xArr, yArr</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    函数说明：计算回归系数theta  </span></span><br><span class="line"><span class="string">    :param xArr: x数据集  </span></span><br><span class="line"><span class="string">    :param yArr: y数据集  </span></span><br><span class="line"><span class="string">    :return: 无  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    xMat = np.asmatrix(xArr)  </span><br><span class="line">    yMat = np.asmatrix(yArr).T  </span><br><span class="line">    xTx = xMat.T * xMat  </span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(xTx) == <span class="number">0.0</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;矩阵为奇异矩阵，不能求逆&#x27;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    theta = xTx.I * (xMat.T * yMat)  </span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><p><em>但是我们应该发现，这个公式中含有逆矩阵，然而现实中往往数据不可逆，因此最小二乘法不能适用于所有模型，而且，我们希望模型是不断从数据样本中学到有用的东西，而不是一步求解。</em><br>我们应该找一种更普遍的方法，目光看向梯度下降。</p><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><h5 id="理解思路"><a href="#理解思路" class="headerlink" title="理解思路"></a>理解思路</h5><p>直观说梯度下降法的话，就是：</p><blockquote><p>我站在高山上，我想用最短的时间下山，但是每次只能走一步。那么我需要做的就是环顾一周，找到一个最陡峭的方向，然后移动到那个点上；到新位置之后，重复刚才的动作。每次都选择最陡峭的方向走，那么很快就能下山。</p></blockquote><p>就像这样：<br><img src="/images/Pasted image 20241026163100.png" style="zoom:300%;"/><br>条条道路通罗马，但是从图像来看，不同起点到的最低点不一定一样<br>那是不是需要从所有地方出发，拿到所有情况呢？</p><p>答案是否定的<br>因为损失函数的图长这样：<br><img src="/images/Pasted image 20241026163114.png" style="zoom:200%;"/><br>不用担心，它就是一个碗而已。</p><p>既然行得通，我们就放心考虑思路<br>最小梯度法的整体思路就是：<br>    1. 对θ进行赋值，这个值随机，通常复值一个全零的向量<br>    2. 不停迭代，每次迭代都改变θ，使得损失函数按照梯度下降的方向进行减少</p><h5 id="具体落实"><a href="#具体落实" class="headerlink" title="具体落实"></a>具体落实</h5><p>确定了下山要一步一步走，具体怎么落实呢？<br>很简单：找一个方向，走一步</p><ul><li><p><strong>找一个方向</strong></p><blockquote><p>下山哪个方向才是最陡峭的呢？<br>  首先想到的是斜率，在我数学知识不多的印象中：斜率越大越陡峭<br>  通过斜率又不难想到导数，所以这定是与导数相关的。<br>  简而言之就是<em>这一步</em>由<em>上一步的基础</em>和<em>某个导数</em>确定$$这一步 &#x3D; 上一步 ？ 某导数$$<br>  推不下去了，就拿出结论吧：$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$  </p></blockquote></li><li><p><strong>走一步</strong></p><blockquote><p>一步走多远？<br>上面式子中的α称为学习率(learning rate)，直白的说就是每一步的步长。<br>    1.α太大可能错过最小值，最后不收敛<br>        想象一下一个人一步可以跨的很大，大到可以从这个山头跨到那个山头，那么这个人就永远不能下山，一直在两个山头反复横跳<br>    2.α太小又会迭代很多次，消耗资源<br>        想象一下小碎步下山<br>拿张图就明白了<br><img src="/images/Pasted image 20241027162552.png" style="zoom:200%;"/></p></blockquote></li></ul><p>下山的关键就是那个迭代公式！<br>$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$<br>对损失函数 ∇J(θ) 关于参数 θ 的偏导数（梯度）是：<br>$$∇J(θ) &#x3D; \frac{\partial J(\theta)}{\partial\theta} &#x3D; \frac{2}{m} X^T(X\theta - y)$$</p><p>数学转换，得到：<br>$$θ &#x3D; θ - \alpha(\frac{2}{m} X^T(X\theta - y))$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加偏置项</span></span><br><span class="line">X_b = np.c_[np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>)), X]  <span class="comment"># 在X的前面加一列1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">alpha = <span class="number">0.1</span>  <span class="comment"># 学习率</span></span><br><span class="line">iterations = <span class="number">1000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 随机初始化权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降算法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    predictions = X_b.dot(theta)  <span class="comment"># 计算预测值</span></span><br><span class="line">    errors = predictions - y  <span class="comment"># 计算误差</span></span><br><span class="line">    gradients = (<span class="number">2</span> / <span class="built_in">len</span>(X_b)) * X_b.T.dot(errors)  <span class="comment"># 计算梯度</span></span><br><span class="line">    theta -= alpha * gradients  <span class="comment"># 更新权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最终的权重</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终的权重:&quot;</span>, theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习率通过不断尝试，得到最佳</p><p>还值得一提的是：</p><h5 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h5><p>为什么缩放？<br>特征值的范围是有差距的，有的特征影响大，有的影响小<br>就像你要竞选主席，你是中国公民这一特征的影响就远远小于你政治能力地位这一特征<br><img src="/images/Pasted image 20241027150630.png" style="zoom:200%;"/></p><p>为了让机器在读取数据的时候感觉更“舒服”，训练起来效率更高，还需要进行特征的缩放<br><img src="/images/Pasted image 20241027150856.png" style="zoom:200%;"/></p><p>特征缩放的常用方法</p><ul><li>最大值缩放 <img src="/images/Pasted image 20241028060744.png" style="zoom:200%;"/></li><li>均值归一化<img src="/images/Pasted image 20241027151409.png" style="zoom:200%;"/></li><li>Z-score 标准化<img src="/images/Pasted image 20241027151659.png" style="zoom:200%;"/></li></ul><p><br><br><br><br><br>放一些练手的连接，怕自己忘记了<br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/5.Week%202%20practice%20lab%20Linear%20regression/.ipynb_checkpoints/C1_W2_Linear_Regression%20-%20%E5%89%AF%E6%9C%AC-checkpoint.ipynb" target="_blank">使用一个变量实施线性回归，以预测餐厅特许经营的利润</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab05_Sklearn_GD_Soln.ipynb" target="_blank">利用 scikit-learn 使用 Gradient Descent 实现线性回归</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab06_Sklearn_Normal_Soln.ipynb" target="_blank">利用 scikit-learn 使用基于正态方程的紧密形式解实现线性回归</a><br><br><br><br><br>写在最后，感谢这些文章和视频对我的指点：<br><a href="https://www.kaggle.com/code/tohuangjia/linear-regression">https://www.kaggle.com/code/tohuangjia/linear-regression</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html">https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html</a><br><a href="https://blog.csdn.net/didiaopao/article/details/126483324">https://blog.csdn.net/didiaopao/article/details/126483324</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb</a><br><a href="https://njuferret.github.io/2017/08/24/Gradient-Descent/">https://njuferret.github.io/2017/08/24/Gradient-Descent/</a><br><a href="https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html">https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&vd_source=696b6322fafa5344c9a7c99a18c22374">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;vd_source=696b6322fafa5344c9a7c99a18c22374</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 最小二乘法 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode209(长度最小的子数组)</title>
      <link href="/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/"/>
      <url>/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-长度最小的子数组"><a href="#滑动窗口-长度最小的子数组" class="headerlink" title="滑动窗口(长度最小的子数组)"></a>滑动窗口(长度最小的子数组)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode209.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>跟一般思维不一样的是，滑动窗口不是往后面进行遍历，关注点在前面</li><li>如何移动初始指针<ul><li>很奇妙的一个点在于 <code>sum = sum - nums[i]</code> ，这样求和就不用再进行遍历</li></ul></li><li>为什么选择 <code>while</code> 而不用 <code>if</code><ul><li><code>if</code> 只执行一次，一次之后集合之和还是大于 <code>target</code> 就不对了，用while的话还能够将 <code>left</code> 向后移动，直到满足 <code>sum &gt;= target</code></li></ul></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line"></span><br><span class="line">        sum += nums[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line"></span><br><span class="line">            sum -= nums[i];</span><br><span class="line"></span><br><span class="line">            len = j - i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            result = len &lt; result ? len : result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方leetcode977(双指针经典)</title>
      <link href="/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/"/>
      <url>/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode977.png" alt="24" align="left"/><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>用双指针，为什么要用双指针？怎么想到要用双指针？</p><p>分析题目，数据是开头大，结尾大，中间小，总体成两边高中间矮的情形，就应该想到比较首尾，就应该联想到双指针。</p><p>如果i比j大，放入i，然后i++，如果j比i大，放如j，然后j–。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .Note: The returned array must be malloced, assume caller calls free()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> , j=numsSize<span class="number">-1</span> ; i&lt;=j ; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]*nums[j]&gt;nums[i]*nums[i])&#123;</span><br><span class="line">            result[k] = nums[j]*nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k] = nums[i]*nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎笔(2024.10.14)</title>
      <link href="/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/"/>
      <url>/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h4 id="一些碎笔"><a href="#一些碎笔" class="headerlink" title="一些碎笔"></a>一些碎笔</h4><p>进实验室大概有个把月吧，跟着也写了搜索引擎，今天进行了检查。老师很不满意。</p><p>说认真也认真，熬了夜的也是，说懒散也懒散，随随便便，想着写着。</p><p>加压？减压？不知道。明天？后天？不知道。痴呆？迟钝？不知道。</p><p>我本来觉着还不错，倒是凉水一盆，清醒了不少。</p><p>要求低了吧我对自己，也太容易飘飘然了吧。</p><p>收拾收拾，继续往前走吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode69(x的平方根)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-x的平方根"><a href="#二分查找-x的平方根" class="headerlink" title="二分查找(x的平方根)"></a>二分查找(x的平方根)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode69.png" alt="22" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>当  <code>middle *  middle &lt;= x</code>  的时候说明middle是潜在的答案，但是答案可能更大，我们要继续往右找，所以先记录  <code>ans = middle</code>  ，再将 left 刷新。</p></blockquote><blockquote><p>为了防止溢出，将  <code>middle *  middle &lt;= x</code>  改为 <code>middle &lt;=  x / middle</code>  </p></blockquote><blockquote><p>这里采用的是左闭右闭，这里注意的是原本  <code>right = x - 1</code>   改成了 <code>right == x</code>  (左闭右开同理)<br>区分基础二分法，因为基础中是基于数组的，最末下标是  <code>numsSize - 1</code>  ，本题不存在下标越界，最末就是 x ，左闭右开，<code>right == x + 1</code> ，左闭右闭，<code>right = x</code> </p></blockquote><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = x, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode704(基础)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-基础"><a href="#二分查找-基础" class="headerlink" title="二分查找(基础)"></a>二分查找(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>有序数组，无重复元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>左闭右开，左闭右闭</p></blockquote><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><h6 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h6><img src="/images/leetcode704.png" alt="16" style="zoom:100%;" align="left"/><h6 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* num,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; num[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; num[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == nums[middle])</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,left,middle,target);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,middle + <span class="number">1</span>,right,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums,<span class="number">0</span>,numsSize,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>越界避免：可以将  <code>middle == (left + right)/2</code>  改成  <code>middle = right - (right - left)/2</code>  ，但是同时会增加运行时间。</p><p>（整数计算过程中也不能超过  <code>int</code>  的范围）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode367(有效的完全平方数)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-有效的完全平方数-、"><a href="#二分查找-有效的完全平方数-、" class="headerlink" title="二分查找(有效的完全平方数)、"></a>二分查找(有效的完全平方数)、</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode367.png" alt="23" style="zoom:100%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>这道题主要是防止溢出 <code>long long ride = (long long)middle * middle</code>  ，还有就是  <code>int middle = right - (right - left)/2</code>  ，要思考的点在于，什么时候用 <code>right - (right - left)/2</code>  代替  <code>(right + left)/2</code>  ，注意根据具体题目判断是否会越 <code>int</code> 界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 排除非正数的情况</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = num;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = right - (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ride = (<span class="type">long</span> <span class="type">long</span>)middle * middle;</span><br><span class="line">        <span class="keyword">if</span>(ride == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ride &lt; num)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode35(搜索插入位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-搜索插入位置"><a href="#二分查找-搜索插入位置" class="headerlink" title="二分查找(搜索插入位置)"></a>二分查找(搜索插入位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode35.png" alt="17" style="zoom:80%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>要是没有找到，哪一个才是插入坐标？(主要针对左闭右开)</p></blockquote><p>没有找到时，left是等于right的，其实是等于上一次的middle的(二分查找过程中是逼近target的过程)，上一次的middle就是target，所以没找到时，应当返回right或者left+1</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums [middle] == target)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode34(查找元素的第一个和最后一个位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-查找元素的第一个和最后一个位置"><a href="#二分查找-查找元素的第一个和最后一个位置" class="headerlink" title="二分查找(查找元素的第一个和最后一个位置)"></a>二分查找(查找元素的第一个和最后一个位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode34.png" alt="21" style="zoom:60%;" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>两种方向：</p><ol><li>通过基础的二分法找到target然后左右扩散，找到最左和最右(第一步二分，第二步遍历，适用于target重复数量不是特别大)</li><li>将  <code>nums[middle]==target</code>  的时候不返回，继续收缩(全是二分法，适用于target重复数量很大</li></ol><p>​寻找左边界的时候，<code>nums[middle]==target</code>  不能停止，因为左边也许还有，所以要继续收缩右边界</p><p>​同理，寻找右边界时，找到了相等还应当继续收缩左边界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findTarget</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[middle])&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">findBorder</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target,<span class="type">int</span> border,<span class="type">int</span>* result)</span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = border;</span><br><span class="line">    result[<span class="number">1</span>] = border;</span><br><span class="line">    <span class="type">int</span> leftBorder = border;</span><br><span class="line">    <span class="type">int</span> rightBorder = border;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(border != <span class="number">0</span>)&#123;<span class="comment">//需要找左边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(leftBorder &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[leftBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftBorder--;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>] = leftBorder + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(border != numsSize - <span class="number">1</span>)&#123;<span class="comment">//需要找右边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(rightBorder &lt; numsSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[rightBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rightBorder++;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">1</span>] = rightBorder - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   * returnSize = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">   result[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">int</span> target0 = findTarget(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">if</span>(target0 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> findBorder(nums,numsSize,target,target0,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; numsSize &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findLast</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; nums[right - <span class="number">1</span>] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = findFirst(nums,numsSize,target);</span><br><span class="line">   result[<span class="number">1</span>] = findLast(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode26(删除有序数组中的重复项)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-删除有序数组中的重复项"><a href="#移除元素-删除有序数组中的重复项" class="headerlink" title="移除元素(删除有序数组中的重复项)"></a>移除元素(删除有序数组中的重复项)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode26.png" alt="25" style="zoom:50%;" align="left" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>与基础双指针相比，本题为什么  <code>fastIndex = 1</code>   而不等于0，为什么先  <code>slowIndex++</code> 后赋值</p></blockquote><p>​     基础的给定了一个target，fast从零开始排查，而本题，是删除重复元素，不用排查第一个</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="正确解答"><a href="#正确解答" class="headerlink" title="正确解答"></a>正确解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            slowIndex++;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="错误解答"><a href="#错误解答" class="headerlink" title="错误解答"></a>错误解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="正误对比分析"><a href="#正误对比分析" class="headerlink" title="正误对比分析"></a>正误对比分析</h6><blockquote><p>本题没有给target，所以需要自行判断target，我们采用的方法就是后者比较前者，所以fast和slow要有差</p></blockquote><p>​     虽然两种解答乍一看是一样的，但是错误解答中就忽略了二者必须有差这一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode27(基础)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-基础"><a href="#移除元素-基础" class="headerlink" title="移除元素(基础)"></a>移除元素(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>数组，移除指定内容的元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>暴力解法，遍历，找到元素就将后一个内容赋给前一个</p></blockquote><blockquote><p>快慢指针法，遍历，任何时候都将快指针前移，没有找到元素的时候，快指针内容赋值给慢指针，慢指针前移</p></blockquote><p>​     <a href="https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3">https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3</a> ( 1分55 )<br>   【Leetcode 27 移除元素 【快慢指针】】</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode27.png" alt="24" align="left"/><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-暴力"><a href="#解法1-暴力" class="headerlink" title="解法1(暴力)"></a>解法1(暴力)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;<span class="comment">//如果找到一样的，那么后面的元素依次往前移动</span></span><br><span class="line">                nums[j<span class="number">-1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;<span class="comment">//下标i以后的数值都向前移动了一位，i也要往前移动一位</span></span><br><span class="line">            numsSize--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-快慢指针法"><a href="#解法2-快慢指针法" class="headerlink" title="解法2(快慢指针法)"></a>解法2(快慢指针法)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="type">int</span> fast_index = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> slow_index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(fast_index=<span class="number">0</span>;fast_index&lt;numsSize;fast_index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast_index] != val)&#123;</span><br><span class="line">            nums[slow_index] = nums[fast_index];</span><br><span class="line">            slow_index++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode844(比较含退格元素的字符串)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-比较含退格的字符串"><a href="#移除元素-比较含退格的字符串" class="headerlink" title="移除元素(比较含退格的字符串)"></a>移除元素(比较含退格的字符串)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode844.png" alt="3" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>其实思路都是得到处理后的字符串进行比较，不同点就在于怎样处理字符串</p></blockquote><ol><li>每个字符串两个空间，一个用来遍历判断，一个用来存放处理后的字符</li></ol><p>​如果是退格符，就栈顶弹出；如果是普通字符，就压入栈中</p><ol start="2"><li><p>双指针</p><p>在原本的空间基础上进行处理。如果快指针不指向退格符，就将所指字符赋给慢指针指向的空间；如果快指针指向退格符，说明需要将慢指针所指向的内容删除就，慢指针后退，这里有一个易错点就是慢指针退到零了就退不了了，要注意下标不要越界。</p></li></ol><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-两个数组空间"><a href="#解法1-两个数组空间" class="headerlink" title="解法1(两个数组空间)"></a>解法1(两个数组空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str), len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n + <span class="number">1</span>)); <span class="comment">//多一个用来存放终止符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            ret[len++] == str[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s),build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-双指针-一个空间"><a href="#解法2-双指针-一个空间" class="headerlink" title="解法2(双指针,一个空间)"></a>解法2(双指针,一个空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex; str[fastIndex] != <span class="string">&#x27;\0&#x27;</span>; fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[fastIndex] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            str[slowIndex++] = str[fastIndex];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(slowIndex &gt; <span class="number">0</span>)&#123;<span class="comment">//这里的判断条件容易忽略</span></span><br><span class="line">            slowIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[slowIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s), build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode283(移动零)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-移动零"><a href="#移除元素-移动零" class="headerlink" title="移除元素(移动零)"></a>移除元素(移动零)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode283.png" alt="26" style="zoom:50%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>为什么要调换位置</p></blockquote><p>​     遍历时，如果没有遍历过0元素，那么fast和slow指针的位置始终相同，交换位置不会影响结果。一旦遍历过0元素，那么slow就停到最左边零的位置，此时当right遍历到非零元素时，就会和最左边的零互换。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解答1-双循环"><a href="#解答1-双循环" class="headerlink" title="解答1(双循环)"></a>解答1(双循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(slowIndex;slowIndex&lt;numsSize;slowIndex++)&#123;</span><br><span class="line">        nums[slowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解答2-单循环"><a href="#解答2-单循环" class="headerlink" title="解答2(单循环)"></a>解答2(单循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp = nums[fastIndex];</span><br><span class="line">            nums[fastIndex] = nums[slowIndex];</span><br><span class="line">            nums[slowIndex] = temp;</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
