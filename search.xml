<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口leetcode76(最小覆盖子串)</title>
      <link href="/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/"/>
      <url>/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-最小覆盖子串"><a href="#滑动窗口-最小覆盖子串" class="headerlink" title="滑动窗口(最小覆盖子串)"></a>滑动窗口(最小覆盖子串)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode76.png" alt="26" style="zoom:50%;" align="left"/><img src="/images/leetcode76.jpg" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>窗口中频率达到要求的字母数量&#x3D;t中的字母种量，就表明我们找到一个子串，但不一定是最小子串。<code>required == formed</code>。用两个数组来记录频率，巧妙地将ASCII码当做下标，使得字母和频率一一对应。<code>int tFreq[128] = &#123;0&#125;, windowFreq[128] = &#123;0&#125;;</code>。这个过程是<strong>扩展右边界</strong>的过程。</p></blockquote><blockquote><p>当找到一个子串时，我们就应该寻找下一个子串，这个时候就应收缩窗口，移动左边界。顺带长度。收缩之后，有可能减少的那个就是我们需要的那个，我们要检查一下满足的数量<code>formed</code>是否减少。这个过程就是<strong>收缩左边界的过程</strong>。</p></blockquote><blockquote><p>我在<code>left &lt; right</code>还是<code>left &lt;= right</code>这一点犯了一些迷糊。答案显然是后者，因为当<code>left == right</code>的时候，说明这个字符串只有一个字母，难道只有一个字母就不去检查更新了吗，肯定不对啊。随意这个时候还是应当进入循环，所以选择<code>&lt;=</code>。</p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">minWindow</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> window_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;, t_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> required = <span class="number">0</span>, formed = <span class="number">0</span>, start = <span class="number">0</span>, min_len = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计t中每个字符出现的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; t[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t_freq[t[i]] == <span class="number">0</span>) required++;</span><br><span class="line">t_freq[t[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line"><span class="type">char</span> ch = s[right];</span><br><span class="line">whidow_freq[ch]++;</span><br><span class="line"><span class="keyword">if</span>(t_freq[ch] &gt; <span class="number">0</span> &amp;&amp; window_freq[ch] == t_freq[ch]) formed++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; formed == required)&#123;</span><br><span class="line"><span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; min_len)&#123;</span><br><span class="line">min_len = right - left + <span class="number">1</span>;</span><br><span class="line">start = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除左边字符并且更新窗口状态</span></span><br><span class="line"><span class="type">char</span> left_char = s[left];</span><br><span class="line">widow_freq[left_char]--;</span><br><span class="line"><span class="keyword">if</span>(t_freqp[left_char] &gt; <span class="number">0</span> </span><br><span class="line">&amp;&amp; window_freq[letf_char] &lt; t_freq[letf_char]) formed--;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min_len == INT_MAX) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* result = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(min_len+<span class="number">1</span>));</span><br><span class="line">result[min_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题感觉很难，但本质上是滑动窗口，对比分析一下基础的滑动窗口<a href="https://sorcerer.zeabur.app/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/" target="_blank">滑动窗口leetcode209(长度最小的子数组)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode904(水果成篮)</title>
      <link href="/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/"/>
      <url>/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-水果成篮"><a href="#滑动窗口-水果成篮" class="headerlink" title="滑动窗口(水果成篮)"></a>滑动窗口(水果成篮)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode904.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>扩大和缩小</p></blockquote><p>如果满足要求，那就扩大右边界<br>如果不满足要求，就缩小左边界</p><p>怎么判断是否满足要求呢？种类数量，实现方法是用一个数组来存放每种水果放在篮子里的数量</p><p>同样存在while和if的选择，缩小时采用的是while，原因左边可能存在连续的并且内容一致的，要一直缩小到满足条件。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>* fruits, <span class="type">int</span> fruitsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> basket[<span class="number">100001</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录每种水果的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_num = <span class="number">0</span>, unique_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; fruitsSize)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被放入篮子，就将它添加到篮子中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(basket[fruits[right]] == <span class="number">0</span>) unique_num++;</span><br><span class="line"></span><br><span class="line">        basket[fruits[right]]++;</span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//当篮子中水果种类超过2时，移动左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(unique_num &gt; <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">            basket[fruits[left]]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(basket[fruits[left]] == <span class="number">0</span>) unique_num--;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新最大水果数量</span></span><br><span class="line"></span><br><span class="line">        max_num = (right - left &gt; max_num) ? (right - left) : max_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之逻辑回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h2><blockquote><p>逻辑回归是根据给定的数据集估算时间发生的概率，是一种分类</p></blockquote><blockquote><p>明明是分类为什么称作回归呢？<br>因为它的底层方法就是线性回归，逻辑回归是基于回归的伪回归算法。</p></blockquote><h2 id="实现基础的逻辑回归"><a href="#实现基础的逻辑回归" class="headerlink" title="实现基础的逻辑回归"></a>实现基础的逻辑回归</h2><h3 id="理解逻辑回归"><a href="#理解逻辑回归" class="headerlink" title="理解逻辑回归"></a>理解逻辑回归</h3><h4 id="逻辑函数的表达"><a href="#逻辑函数的表达" class="headerlink" title="逻辑函数的表达"></a>逻辑函数的表达</h4><p>回想线性方程<br>$$Z &#x3D; W^TX + b$$<br>对于直线，我们知道z的输出范围没有任何的限制，可以从负无穷到正无穷。但是，我们需要的是一个分类器，想要拿到两种结果，0或者1，所以我们需要输出范围为（0,1）的式子。<br>在线性方程的基础上达到规范输出范围这一目的，我们使用了Sigmoid函数$$σ(z) &#x3D; \frac{1}{1+e^{-z}}$$</p><img src="/images/Pasted image 20241028195414.png" style="zoom:200%;"/>图像很像s，就跟sigmoid沾上边了，所以拿到一个逻辑函数的名称。<p>我们在z的基础上进行的操作来达到控制范围的效果，我们就将z代入，就像下面这样。<br><img src="/images/Pasted image 20241028182720.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028190843.png" style="zoom:200%;"/><br>我们要明确最初的目标，是分类，只有两种结果，要么0要么1，那哪些判断为0哪些判断为1呢？<br>我们引入决策边界。边界内为一种情况，边界外为一种情况。<br>不难想到会有线性边界以及非线性边界<br>情况类似下图<br><img src="/images/Pasted image 20241028200239.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028183305.png" style="zoom:200%;"/></p><blockquote><p>所以，逻辑回归的整体思路是，先用逻辑函数把线性回归的结果 (-∞,∞)映射到(0,1)，再通过决策边界建立与分类的概率联系</p></blockquote><p>在二分类模型中，事件发生于不发生的概率之比$$\frac{p}{1-p}$$称作事件的几率。<br>几率的范围也是(0,1)，那我们就令<br>$$z &#x3D; log(\frac{p}{1-p})$$<br>也就是说，线性回归的结果等于对数几率。</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>自然，向线性回归一样，逻辑回归也需要我们判断拟合好与不好。</p><p>线性回归分析梯度下降时，我们就提出了，条条大路不一定都能通罗马，恰好线性回归的损失函数是一个碗罢了，只有一个最小。<br>那逻辑回归还会这么幸运吗？<br>并不是，逻辑函数的平方损失函数布满了局部最小值。<br><img src="/images/Pasted image 20241028183938.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028191058.png" style="zoom:200%;"/><br>这样一来，梯度下降难以实行啊。为了解决这个问题，我们得让它也像碗一样听话。</p><p>痛苦的根源是什么？有个e啊！还在分母上，怎么导也动不了啊！联想一下高考导数题，不难想到取对数。试一试，取对数情况很不错。</p><p>y要么为0要么为1，看一看对数的图像<br><img src="/images/Pasted image 20241028202156.png" style="zoom:200%;"/><br>如果是一根线，那么不管怎么个情况，0和1对应取到的值都是天壤之别。</p><p>一根不能满足，两根就可以。一正一负，很合适。看看下面三张图：<br><img src="/images/Pasted image 20241028185200.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028184731.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028185001.png" style="zoom:200%;"/></p><p>取对数，图形就变得很乖了，看不出坑坑洼洼。<br><img src="/images/Pasted image 20241028191229.png" style="zoom:200%;"/><br>这下就适合梯度下降了。</p><p>化简一下：<br><img src="/images/Pasted image 20241028192104.png" style="zoom:200%;"/></p><p>接下来就是线性回归一样的梯度下降处理了<br><img src="/images/Pasted image 20241028192602.png" style="zoom:200%;"/></p><p>不难看出，求的偏导跟线性回归好像一样。<br>但是区别就在于f的表达式。</p><p>剩下的处理跟线性回归也就大差不差了。详情可见<a href="https://sorcerer.zeabur.app/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" target="_blank">机器学习之逻辑回归基础</a></p><p><br><br><br><br><br>写在最后，感谢这些文章和视屏的指点：<br><a href="https://juejin.cn/post/7057447537757650957">https://juejin.cn/post/7057447537757650957</a><br><a href="https://blog.csdn.net/weixin_48524215/article/details/131350759">https://blog.csdn.net/weixin_48524215/article/details/131350759</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之线性回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h2 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h2><h3 id="什么是回归"><a href="#什么是回归" class="headerlink" title="什么是回归"></a>什么是回归</h3><blockquote><p>回归问题是函数拟合问题，就是给定一些点的集合，用一个曲线或者方程去拟合，使得所有点都大致符合</p></blockquote><h3 id="什么是线性回归-1"><a href="#什么是线性回归-1" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h3><blockquote><p>拟合的是一条直线，那就是线性回归</p></blockquote><h2 id="实现基础的线性回归"><a href="#实现基础的线性回归" class="headerlink" title="实现基础的线性回归"></a>实现基础的线性回归</h2><h3 id="实现回归的本质"><a href="#实现回归的本质" class="headerlink" title="实现回归的本质"></a>实现回归的本质</h3><p>拿到一个<em>好方程</em>，输入已知量(自变量)，就能通过这个方程预测未知量(我们想要的数据)</p><h3 id="拟合的方程"><a href="#拟合的方程" class="headerlink" title="拟合的方程"></a>拟合的方程</h3><p>我们假设能够拟合的方程是:<br>$$<br>h_\theta(x) &#x3D; \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \ldots + \theta_n x_n<br>$$<br>为了一般化这个方程，我们引入常量x0&#x3D;1<br>$$ h_\theta(x_{n\times1)} &#x3D; \sum_{i&#x3D;0}^{n} \theta_i \cdot x_i &#x3D;<br>\theta_{n\times1}^Tx_{1\times n}$$<br>要实现回归，就找到一群系数θ，也就是一个θ向量，也称作特征分量。</p><h3 id="拟合的好坏评价"><a href="#拟合的好坏评价" class="headerlink" title="拟合的好坏评价"></a>拟合的好坏评价</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>这个函数用来衡量我们预测值和真实值之间的差距<br>$$ J(\theta_{n\times1}) &#x3D; \frac{1}{2}\sum_{i&#x3D;1}^m(h_\theta(x_{n_\times1})^{(i)} - y^{(i)})^2$$</p><blockquote><p>(预测值-真实值)的平方，然后对每一组训练数据进行累加<br>需要一提的是，1&#x2F;2不是必要的，只是为了简化推导（最小二乘法的思想）</p></blockquote><p>损失函数的值小，就表明我们的误差小，那么我们的问题就变成了求最小值。<br>求$${minJ\theta}$$</p><h3 id="拟合的算法"><a href="#拟合的算法" class="headerlink" title="拟合的算法"></a>拟合的算法</h3><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><p>显然损失函数是一个关于θ的二次函数，二次函数的图像不外乎像这样：<br><br><img src="/images/Pasted image 20241028030501.png" style="zoom:200%;"/><br>导数为零的时候自然就是损失最小的时候<br>求损失函数关于θ的导数：<br>$$导数 &#x3D; 2{x^T_{n\times1}}(y_{n\times1} - x_{n\times1}\theta_{n\times1})$$<br>令导数为零，得到：<br>$$\theta_{n\times1} &#x3D; (x^T_{n\times1}x_{n\times1})^{-1}x^T_{n\times1}y_{n\times1}$$<br>也就是说代入这个公式，就能拿到合适的θ向量，也就达成了目标。<br>代码实现也不是很困难</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">standRegres</span>(<span class="params">xArr, yArr</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    函数说明：计算回归系数theta  </span></span><br><span class="line"><span class="string">    :param xArr: x数据集  </span></span><br><span class="line"><span class="string">    :param yArr: y数据集  </span></span><br><span class="line"><span class="string">    :return: 无  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    xMat = np.asmatrix(xArr)  </span><br><span class="line">    yMat = np.asmatrix(yArr).T  </span><br><span class="line">    xTx = xMat.T * xMat  </span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(xTx) == <span class="number">0.0</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;矩阵为奇异矩阵，不能求逆&#x27;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    theta = xTx.I * (xMat.T * yMat)  </span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><p><em>但是我们应该发现，这个公式中含有逆矩阵，然而现实中往往数据不可逆，因此最小二乘法不能适用于所有模型，而且，我们希望模型是不断从数据样本中学到有用的东西，而不是一步求解。</em><br>我们应该找一种更普遍的方法，目光看向梯度下降。</p><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><h5 id="理解思路"><a href="#理解思路" class="headerlink" title="理解思路"></a>理解思路</h5><p>直观说梯度下降法的话，就是：</p><blockquote><p>我站在高山上，我想用最短的时间下山，但是每次只能走一步。那么我需要做的就是环顾一周，找到一个最陡峭的方向，然后移动到那个点上；到新位置之后，重复刚才的动作。每次都选择最陡峭的方向走，那么很快就能下山。</p></blockquote><p>就像这样：<br><img src="/images/Pasted image 20241026163100.png" style="zoom:300%;"/><br>条条道路通罗马，但是从图像来看，不同起点到的最低点不一定一样<br>那是不是需要从所有地方出发，拿到所有情况呢？</p><p>答案是否定的<br>因为损失函数的图长这样：<br><img src="/images/Pasted image 20241026163114.png" style="zoom:200%;"/><br>不用担心，它就是一个碗而已。</p><p>既然行得通，我们就放心考虑思路<br>最小梯度法的整体思路就是：<br>    1. 对θ进行赋值，这个值随机，通常复值一个全零的向量<br>    2. 不停迭代，每次迭代都改变θ，使得损失函数按照梯度下降的方向进行减少</p><h5 id="具体落实"><a href="#具体落实" class="headerlink" title="具体落实"></a>具体落实</h5><p>确定了下山要一步一步走，具体怎么落实呢？<br>很简单：找一个方向，走一步</p><ul><li><p><strong>找一个方向</strong></p><blockquote><p>下山哪个方向才是最陡峭的呢？<br>  首先想到的是斜率，在我数学知识不多的印象中：斜率越大越陡峭<br>  通过斜率又不难想到导数，所以这定是与导数相关的。<br>  简而言之就是<em>这一步</em>由<em>上一步的基础</em>和<em>某个导数</em>确定$$这一步 &#x3D; 上一步 ？ 某导数$$<br>  推不下去了，就拿出结论吧：$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$  </p></blockquote></li><li><p><strong>走一步</strong></p><blockquote><p>一步走多远？<br>上面式子中的α称为学习率(learning rate)，直白的说就是每一步的步长。<br>    1.α太大可能错过最小值，最后不收敛<br>        想象一下一个人一步可以跨的很大，大到可以从这个山头跨到那个山头，那么这个人就永远不能下山，一直在两个山头反复横跳<br>    2.α太小又会迭代很多次，消耗资源<br>        想象一下小碎步下山<br>拿张图就明白了<br><img src="/images/Pasted image 20241027162552.png" style="zoom:200%;"/></p></blockquote></li></ul><p>下山的关键就是那个迭代公式！<br>$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$<br>对损失函数 ∇J(θ) 关于参数 θ 的偏导数（梯度）是：<br>$$∇J(θ) &#x3D; \frac{\partial J(\theta)}{\partial\theta} &#x3D; \frac{2}{m} X^T(X\theta - y)$$</p><p>数学转换，得到：<br>$$θ &#x3D; θ - \alpha(\frac{2}{m} X^T(X\theta - y))$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加偏置项</span></span><br><span class="line">X_b = np.c_[np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>)), X]  <span class="comment"># 在X的前面加一列1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">alpha = <span class="number">0.1</span>  <span class="comment"># 学习率</span></span><br><span class="line">iterations = <span class="number">1000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 随机初始化权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降算法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    predictions = X_b.dot(theta)  <span class="comment"># 计算预测值</span></span><br><span class="line">    errors = predictions - y  <span class="comment"># 计算误差</span></span><br><span class="line">    gradients = (<span class="number">2</span> / <span class="built_in">len</span>(X_b)) * X_b.T.dot(errors)  <span class="comment"># 计算梯度</span></span><br><span class="line">    theta -= alpha * gradients  <span class="comment"># 更新权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最终的权重</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终的权重:&quot;</span>, theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习率通过不断尝试，得到最佳</p><p>还值得一提的是：</p><h5 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h5><p>为什么缩放？<br>特征值的范围是有差距的，有的特征影响大，有的影响小<br>就像你要竞选主席，你是中国公民这一特征的影响就远远小于你政治能力地位这一特征<br><img src="/images/Pasted image 20241027150630.png" style="zoom:200%;"/></p><p>为了让机器在读取数据的时候感觉更“舒服”，训练起来效率更高，还需要进行特征的缩放<br><img src="/images/Pasted image 20241027150856.png" style="zoom:200%;"/></p><p>特征缩放的常用方法</p><ul><li>最大值缩放 <img src="/images/Pasted image 20241028060744.png" style="zoom:200%;"/></li><li>均值归一化<img src="/images/Pasted image 20241027151409.png" style="zoom:200%;"/></li><li>Z-score 标准化<img src="/images/Pasted image 20241027151659.png" style="zoom:200%;"/></li></ul><p><br><br><br><br><br>放一些练手的连接，怕自己忘记了<br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/5.Week%202%20practice%20lab%20Linear%20regression/.ipynb_checkpoints/C1_W2_Linear_Regression%20-%20%E5%89%AF%E6%9C%AC-checkpoint.ipynb" target="_blank">使用一个变量实施线性回归，以预测餐厅特许经营的利润</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab05_Sklearn_GD_Soln.ipynb" target="_blank">利用 scikit-learn 使用 Gradient Descent 实现线性回归</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab06_Sklearn_Normal_Soln.ipynb" target="_blank">利用 scikit-learn 使用基于正态方程的紧密形式解实现线性回归</a><br><br><br><br><br>写在最后，感谢这些文章和视频对我的指点：<br><a href="https://www.kaggle.com/code/tohuangjia/linear-regression">https://www.kaggle.com/code/tohuangjia/linear-regression</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html">https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html</a><br><a href="https://blog.csdn.net/didiaopao/article/details/126483324">https://blog.csdn.net/didiaopao/article/details/126483324</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb</a><br><a href="https://njuferret.github.io/2017/08/24/Gradient-Descent/">https://njuferret.github.io/2017/08/24/Gradient-Descent/</a><br><a href="https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html">https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&vd_source=696b6322fafa5344c9a7c99a18c22374">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;vd_source=696b6322fafa5344c9a7c99a18c22374</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 最小二乘法 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode209(长度最小的子数组)</title>
      <link href="/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/"/>
      <url>/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-长度最小的子数组"><a href="#滑动窗口-长度最小的子数组" class="headerlink" title="滑动窗口(长度最小的子数组)"></a>滑动窗口(长度最小的子数组)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode209.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>跟一般思维不一样的是，滑动窗口不是往后面进行遍历，关注点在前面</li><li>如何移动初始指针<ul><li>很奇妙的一个点在于 <code>sum = sum - nums[i]</code> ，这样求和就不用再进行遍历</li></ul></li><li>为什么选择 <code>while</code> 而不用 <code>if</code><ul><li><code>if</code> 只执行一次，一次之后集合之和还是大于 <code>target</code> 就不对了，用while的话还能够将 <code>left</code> 向后移动，直到满足 <code>sum &gt;= target</code></li></ul></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line"></span><br><span class="line">        sum += nums[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line"></span><br><span class="line">            sum -= nums[i];</span><br><span class="line"></span><br><span class="line">            len = j - i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            result = len &lt; result ? len : result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方leetcode977(双指针经典)</title>
      <link href="/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/"/>
      <url>/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode977.png" alt="24" align="left"/><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>用双指针，为什么要用双指针？怎么想到要用双指针？</p><p>分析题目，数据是开头大，结尾大，中间小，总体成两边高中间矮的情形，就应该想到比较首尾，就应该联想到双指针。</p><p>如果i比j大，放入i，然后i++，如果j比i大，放如j，然后j–。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .Note: The returned array must be malloced, assume caller calls free()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> , j=numsSize<span class="number">-1</span> ; i&lt;=j ; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]*nums[j]&gt;nums[i]*nums[i])&#123;</span><br><span class="line">            result[k] = nums[j]*nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k] = nums[i]*nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎笔(2024.10.14)</title>
      <link href="/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/"/>
      <url>/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h4 id="一些碎笔"><a href="#一些碎笔" class="headerlink" title="一些碎笔"></a>一些碎笔</h4><p>进实验室大概有个把月吧，跟着也写了搜索引擎，今天进行了检查。老师很不满意。</p><p>说认真也认真，熬了夜的也是，说懒散也懒散，随随便便，想着写着。</p><p>加压？减压？不知道。明天？后天？不知道。痴呆？迟钝？不知道。</p><p>我本来觉着还不错，倒是凉水一盆，清醒了不少。</p><p>要求低了吧我对自己，也太容易飘飘然了吧。</p><p>收拾收拾，继续往前走吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode69(x的平方根)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-x的平方根"><a href="#二分查找-x的平方根" class="headerlink" title="二分查找(x的平方根)"></a>二分查找(x的平方根)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode69.png" alt="22" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>当  <code>middle *  middle &lt;= x</code>  的时候说明middle是潜在的答案，但是答案可能更大，我们要继续往右找，所以先记录  <code>ans = middle</code>  ，再将 left 刷新。</p></blockquote><blockquote><p>为了防止溢出，将  <code>middle *  middle &lt;= x</code>  改为 <code>middle &lt;=  x / middle</code>  </p></blockquote><blockquote><p>这里采用的是左闭右闭，这里注意的是原本  <code>right = x - 1</code>   改成了 <code>right == x</code>  (左闭右开同理)<br>区分基础二分法，因为基础中是基于数组的，最末下标是  <code>numsSize - 1</code>  ，本题不存在下标越界，最末就是 x ，左闭右开，<code>right == x + 1</code> ，左闭右闭，<code>right = x</code> </p></blockquote><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = x, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode704(基础)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-基础"><a href="#二分查找-基础" class="headerlink" title="二分查找(基础)"></a>二分查找(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>有序数组，无重复元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>左闭右开，左闭右闭</p></blockquote><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><h6 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h6><img src="/images/leetcode704.png" alt="16" style="zoom:100%;" align="left"/><h6 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* num,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; num[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; num[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == nums[middle])</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,left,middle,target);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,middle + <span class="number">1</span>,right,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums,<span class="number">0</span>,numsSize,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>越界避免：可以将  <code>middle == (left + right)/2</code>  改成  <code>middle = right - (right - left)/2</code>  ，但是同时会增加运行时间。</p><p>（整数计算过程中也不能超过  <code>int</code>  的范围）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode367(有效的完全平方数)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-有效的完全平方数-、"><a href="#二分查找-有效的完全平方数-、" class="headerlink" title="二分查找(有效的完全平方数)、"></a>二分查找(有效的完全平方数)、</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode367.png" alt="23" style="zoom:100%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>这道题主要是防止溢出 <code>long long ride = (long long)middle * middle</code>  ，还有就是  <code>int middle = right - (right - left)/2</code>  ，要思考的点在于，什么时候用 <code>right - (right - left)/2</code>  代替  <code>(right + left)/2</code>  ，注意根据具体题目判断是否会越 <code>int</code> 界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 排除非正数的情况</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = num;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = right - (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ride = (<span class="type">long</span> <span class="type">long</span>)middle * middle;</span><br><span class="line">        <span class="keyword">if</span>(ride == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ride &lt; num)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode35(搜索插入位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-搜索插入位置"><a href="#二分查找-搜索插入位置" class="headerlink" title="二分查找(搜索插入位置)"></a>二分查找(搜索插入位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode35.png" alt="17" style="zoom:80%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>要是没有找到，哪一个才是插入坐标？(主要针对左闭右开)</p></blockquote><p>没有找到时，left是等于right的，其实是等于上一次的middle的(二分查找过程中是逼近target的过程)，上一次的middle就是target，所以没找到时，应当返回right或者left+1</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums [middle] == target)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode34(查找元素的第一个和最后一个位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-查找元素的第一个和最后一个位置"><a href="#二分查找-查找元素的第一个和最后一个位置" class="headerlink" title="二分查找(查找元素的第一个和最后一个位置)"></a>二分查找(查找元素的第一个和最后一个位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode34.png" alt="21" style="zoom:60%;" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>两种方向：</p><ol><li>通过基础的二分法找到target然后左右扩散，找到最左和最右(第一步二分，第二步遍历，适用于target重复数量不是特别大)</li><li>将  <code>nums[middle]==target</code>  的时候不返回，继续收缩(全是二分法，适用于target重复数量很大</li></ol><p>​寻找左边界的时候，<code>nums[middle]==target</code>  不能停止，因为左边也许还有，所以要继续收缩右边界</p><p>​同理，寻找右边界时，找到了相等还应当继续收缩左边界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findTarget</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[middle])&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">findBorder</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target,<span class="type">int</span> border,<span class="type">int</span>* result)</span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = border;</span><br><span class="line">    result[<span class="number">1</span>] = border;</span><br><span class="line">    <span class="type">int</span> leftBorder = border;</span><br><span class="line">    <span class="type">int</span> rightBorder = border;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(border != <span class="number">0</span>)&#123;<span class="comment">//需要找左边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(leftBorder &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[leftBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftBorder--;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>] = leftBorder + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(border != numsSize - <span class="number">1</span>)&#123;<span class="comment">//需要找右边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(rightBorder &lt; numsSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[rightBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rightBorder++;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">1</span>] = rightBorder - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   * returnSize = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">   result[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">int</span> target0 = findTarget(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">if</span>(target0 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> findBorder(nums,numsSize,target,target0,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; numsSize &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findLast</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; nums[right - <span class="number">1</span>] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = findFirst(nums,numsSize,target);</span><br><span class="line">   result[<span class="number">1</span>] = findLast(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode26(删除有序数组中的重复项)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-删除有序数组中的重复项"><a href="#移除元素-删除有序数组中的重复项" class="headerlink" title="移除元素(删除有序数组中的重复项)"></a>移除元素(删除有序数组中的重复项)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode26.png" alt="25" style="zoom:50%;" align="left" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>与基础双指针相比，本题为什么  <code>fastIndex = 1</code>   而不等于0，为什么先  <code>slowIndex++</code> 后赋值</p></blockquote><p>​     基础的给定了一个target，fast从零开始排查，而本题，是删除重复元素，不用排查第一个</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="正确解答"><a href="#正确解答" class="headerlink" title="正确解答"></a>正确解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            slowIndex++;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="错误解答"><a href="#错误解答" class="headerlink" title="错误解答"></a>错误解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="正误对比分析"><a href="#正误对比分析" class="headerlink" title="正误对比分析"></a>正误对比分析</h6><blockquote><p>本题没有给target，所以需要自行判断target，我们采用的方法就是后者比较前者，所以fast和slow要有差</p></blockquote><p>​     虽然两种解答乍一看是一样的，但是错误解答中就忽略了二者必须有差这一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode27(基础)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-基础"><a href="#移除元素-基础" class="headerlink" title="移除元素(基础)"></a>移除元素(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>数组，移除指定内容的元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>暴力解法，遍历，找到元素就将后一个内容赋给前一个</p></blockquote><blockquote><p>快慢指针法，遍历，任何时候都将快指针前移，没有找到元素的时候，快指针内容赋值给慢指针，慢指针前移</p></blockquote><p>​     <a href="https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3">https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3</a> ( 1分55 )<br>   【Leetcode 27 移除元素 【快慢指针】】</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode27.png" alt="24" align="left"/><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-暴力"><a href="#解法1-暴力" class="headerlink" title="解法1(暴力)"></a>解法1(暴力)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;<span class="comment">//如果找到一样的，那么后面的元素依次往前移动</span></span><br><span class="line">                nums[j<span class="number">-1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;<span class="comment">//下标i以后的数值都向前移动了一位，i也要往前移动一位</span></span><br><span class="line">            numsSize--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-快慢指针法"><a href="#解法2-快慢指针法" class="headerlink" title="解法2(快慢指针法)"></a>解法2(快慢指针法)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="type">int</span> fast_index = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> slow_index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(fast_index=<span class="number">0</span>;fast_index&lt;numsSize;fast_index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast_index] != val)&#123;</span><br><span class="line">            nums[slow_index] = nums[fast_index];</span><br><span class="line">            slow_index++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode844(比较含退格元素的字符串)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-比较含退格的字符串"><a href="#移除元素-比较含退格的字符串" class="headerlink" title="移除元素(比较含退格的字符串)"></a>移除元素(比较含退格的字符串)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode844.png" alt="3" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>其实思路都是得到处理后的字符串进行比较，不同点就在于怎样处理字符串</p></blockquote><ol><li>每个字符串两个空间，一个用来遍历判断，一个用来存放处理后的字符</li></ol><p>​如果是退格符，就栈顶弹出；如果是普通字符，就压入栈中</p><ol start="2"><li><p>双指针</p><p>在原本的空间基础上进行处理。如果快指针不指向退格符，就将所指字符赋给慢指针指向的空间；如果快指针指向退格符，说明需要将慢指针所指向的内容删除就，慢指针后退，这里有一个易错点就是慢指针退到零了就退不了了，要注意下标不要越界。</p></li></ol><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-两个数组空间"><a href="#解法1-两个数组空间" class="headerlink" title="解法1(两个数组空间)"></a>解法1(两个数组空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str), len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n + <span class="number">1</span>)); <span class="comment">//多一个用来存放终止符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            ret[len++] == str[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s),build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-双指针-一个空间"><a href="#解法2-双指针-一个空间" class="headerlink" title="解法2(双指针,一个空间)"></a>解法2(双指针,一个空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex; str[fastIndex] != <span class="string">&#x27;\0&#x27;</span>; fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[fastIndex] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            str[slowIndex++] = str[fastIndex];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(slowIndex &gt; <span class="number">0</span>)&#123;<span class="comment">//这里的判断条件容易忽略</span></span><br><span class="line">            slowIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[slowIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s), build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode283(移动零)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-移动零"><a href="#移除元素-移动零" class="headerlink" title="移除元素(移动零)"></a>移除元素(移动零)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode283.png" alt="26" style="zoom:50%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>为什么要调换位置</p></blockquote><p>​     遍历时，如果没有遍历过0元素，那么fast和slow指针的位置始终相同，交换位置不会影响结果。一旦遍历过0元素，那么slow就停到最左边零的位置，此时当right遍历到非零元素时，就会和最左边的零互换。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解答1-双循环"><a href="#解答1-双循环" class="headerlink" title="解答1(双循环)"></a>解答1(双循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(slowIndex;slowIndex&lt;numsSize;slowIndex++)&#123;</span><br><span class="line">        nums[slowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解答2-单循环"><a href="#解答2-单循环" class="headerlink" title="解答2(单循环)"></a>解答2(单循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp = nums[fastIndex];</span><br><span class="line">            nums[fastIndex] = nums[slowIndex];</span><br><span class="line">            nums[slowIndex] = temp;</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
