<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>K-Means++</title>
      <link href="/2024/11/04/K-Means++/"/>
      <url>/2024/11/04/K-Means++/</url>
      
        <content type="html"><![CDATA[<h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means++"></a>K-Means++</h1><h2 id="什么是k-means"><a href="#什么是k-means" class="headerlink" title="什么是k-means++"></a>什么是k-means++</h2><p><strong>K-means++</strong> 是一种改进的质心初始化方法，用来解决 K-means 聚类算法对初始质心敏感的问题。通过 K-means++ 的初始化方式，可以使 K-means 更加稳定、快速地收敛，同时提高找到全局最优解的可能性。</p><h2 id="k-means-的主要思想"><a href="#k-means-的主要思想" class="headerlink" title="k-means++的主要思想"></a>k-means++的主要思想</h2><p>在选择灭一个新的初始质心时，<mark>优先选择离已有质心较远的点</mark>，这样可以确保初始质心尽量分散，覆盖数据的主要区域，从而减少迭代次数，降低陷入局部最优解的可能性。</p><h2 id="为什么k-means-有效"><a href="#为什么k-means-有效" class="headerlink" title="为什么k-means++有效"></a>为什么k-means++有效</h2><p>首先可以看一组对比图：<br>![[output.png]]</p><ol><li>减少了局部最优的风险：K-means 的随机初始化容易导致质心集中在数据的某个局部区域，导致算法陷入局部最优。K-means++ 通过让质心分散，从而增加找到全局最优解的可能性。</li><li>加速收敛：初始质心更合理时，数据点会更接近其正确的簇，减少了算法调整质心位置的工作量，从而加快收敛。</li><li>平衡簇的大小：通过选择离现有质心较远的数据点作为新的质心，K-means++ 在初始化时就确保簇分布较均匀，避免出现某些簇过大或过小的情况。</li></ol><h2 id="k-means-的步骤"><a href="#k-means-的步骤" class="headerlink" title="k-means++的步骤"></a>k-means++的步骤</h2><ol><li>随机选择第一个质心：从数据集中选择一个数据点作为第一个质心。</li><li>计算每个数据点到最近质心的距离记为D(x)。同k-means，这篇文章当中有讲到这一点[[机器学习之聚类算法]]</li><li>概率选择下一个质心<ol><li>选择下一个质心时，不是完全随机选择，而是根据距离的平方来确定选择的概率。</li><li>将每个数据点x以D(x)的平方作为概率选择为下一个质心，具体来说，距离越远的点有更高的概率被选为新的质心。</li></ol></li><li>重复2和3，直到选择了K个质心。</li><li>开始标准的K-means迭代：使用初始化得到的K个质心，按照标准的K-means算法进行迭代，直到算法收敛。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里实现最关键的<mark>确定质心</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_centroids_kmeans_pp</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 K-means++ 方法初始化质心.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    - X: 数据集 (numpy array)，形状为 (n_samples, n_features)</span></span><br><span class="line"><span class="string">    - K: 需要生成的簇数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    - centroids: 初始化的 K 个质心，形状为 (K, n_features)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取样本数和特征数</span></span><br><span class="line">    n_samples, n_features = X.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个空的质心数组</span></span><br><span class="line">    centroids = np.zeros((K, n_features))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机选择第一个质心</span></span><br><span class="line">    centroids[<span class="number">0</span>] = X[np.random.randint(<span class="number">0</span>, n_samples)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择接下来的质心</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">        <span class="comment"># 计算每个数据点到最近已选质心的距离平方</span></span><br><span class="line">        distances = np.<span class="built_in">min</span>([np.linalg.norm(X - centroid, axis=<span class="number">1</span>)**<span class="number">2</span> <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids[:i]], axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 依据距离平方，按比例选择下一个质心</span></span><br><span class="line">        probabilities = distances / distances.<span class="built_in">sum</span>()</span><br><span class="line">        cumulative_probabilities = np.cumsum(probabilities)</span><br><span class="line">        r = np.random.rand()</span><br><span class="line">        next_centroid_idx = np.where(cumulative_probabilities &gt;= r)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将选中的数据点作为下一个质心</span></span><br><span class="line">        centroids[i] = X[next_centroid_idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之聚类算法基础</title>
      <link href="/2024/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="什么是聚类"><a href="#什么是聚类" class="headerlink" title="什么是聚类"></a>什么是聚类</h2><blockquote><p>一个班级很多人，随着时间的推移，会形成几个小团体，这个找朋友的过程就叫做聚类。人以类聚，物以群分，数据亦如此。</p></blockquote><blockquote><p>聚类是最常见的无监督学习算法，把一个数据集按照某个特定标准(比如距离)分割成不同类或簇，使得同一个簇内的数据相似性尽可能大，不同簇差异尽可能大<br><img src="/images/Pasted image 20241103201908.png" style="zoom:200%;"/></p></blockquote><h2 id="有哪些聚类"><a href="#有哪些聚类" class="headerlink" title="有哪些聚类"></a>有哪些聚类</h2><p>找朋友肯定要有一定的标准吧，比如我是柯哀党，你是新兰党，肯定是水火不容不能分为一类的。根据不同分割标准，我们有很多种的聚类算法，下图陈列了一些。其中k-means是一种非常经典的聚类算法，古老但实用。本文主要针对k-means进行讨论。<br><img src="/images/Pasted image 20241103203619.png" style="zoom:200%;"/></p><h2 id="怎样实现聚类"><a href="#怎样实现聚类" class="headerlink" title="怎样实现聚类"></a>怎样实现聚类</h2><h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p><mark>k-means是基于划分的聚类</mark></p><h5 id="质心"><a href="#质心" class="headerlink" title="质心"></a>质心</h5><p>一个团体总有一个核心，比如中国共产党代表全国人民最根本的利益，所有人民都围绕着中国共产党。数据也有一个聚类中心，一类数据(一个簇)会围绕着一个聚类中心。我们将这个聚类中心称作<strong>质心</strong>，我们用μ来表示。<br>$$μ_i &#x3D; \frac{1}{|C_i|}\sum_{x \in C_i} x$$<br>(第i个簇的质心μ是该簇内所有数据点的平均值，也就是中心点)</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>要评价类分得好不好，我们自然要引进损失函数，也称失真函数。<br>$$J(c^{(1)},…c^{(m)}, \mu_1,…\mu_K) &#x3D; \frac{1}{m}||x^{(i)} - \mu_c^{(i)}||^2$$<br>失真函数是表现的簇内点到簇中心的距离平方。距离越远，说明这个团队不够紧密，也就说明这个类聚得不好。<br><img src="/images/Pasted image 20241104172257.png" style="zoom:200%;"/></p><p>我们要使得距离近有什么办法呢？</p><ul><li><p>第一点，每个样本点划分到最近的中心点队列。（群众要紧紧拥护党的领导）</p><blockquote><p>众多的簇内点应该选取合适的簇中心。如下图，x距离红色质心的距离会远小于蓝色质心的距离。<br><img src="/images/Pasted image 20241103125055.png" style="zoom:200%;"/></p></blockquote></li><li><p>第二点，质心应该应该到合适的地方。（党应该深入人民群众）</p><blockquote><p>质心要到中心去，这样总体的距离之和才会小。这是一个数学问题，本质上是高中均值不等式当中的平方均值不等式。<br>$$\frac{a + b}{2} \geq \sqrt{\frac{a^2 + b^2}{2}}  （a&#x3D;b时等号成立）$$<br><img src="/images/Pasted image 20241103125128.png" style="zoom:200%;"/><br>显然有a+b&#x3D;10，那么有<br><img src="/images/Pasted image 20241104164538.png" style="zoom:200%;"/><br>也就是说取均值时，距离平方和最小。所以我们应该算取每个类别中样本点的均值，将均值作为新的中心点。<br><img src="/images/Pasted image 20241104172908.png" style="zoom:200%;"/></p></blockquote></li></ul><p>要实现下来，总共就两步：将样本点分配给最近的质心，根据分配重新计算质心。<br>K-means关键就是这两步，一次一次迭代，最终就能聚类。</p><p>还需要注意的是：</p><ol><li>初始化质心<blockquote><p>最开始是没有质心的，也就没有办法进行分配，所以我们应该初始化质心。怎么初始化，可以取随机的样本点。</p></blockquote></li></ol><blockquote><p>K-Means的质心特别重要，十分敏感。如果最开始的质心没有被分配点，那么求平均值是没有意义的。最常见的做法是消除没有点集群，得到k-1个簇。<br><img src="/images/Pasted image 20241104173001.png" style="zoom:200%;"/><br>我们可以使用K-means++，详情可以参考<a href="https://sorcerer.zeabur.app/2024/11/04/K-Means++/" target="_blank">K-Means++</a></p></blockquote><ol start="2"><li>选择合适的K值（也就是合适的质心数量）<blockquote><p>K值选择不当，会造成过拟合或欠拟合。我们常常选择“肘部法”。<br><img src="/images/Pasted image 20241103132931.png" style="zoom:200%;"/><br>有一个值，过了这个值，损失函数下降的幅度比较小，这个就是我们需要的K。<br>值得一提的是，选择K值并不完全根据损失来定，我们要结合实际情况。</p></blockquote></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>代码实现迭代的k-means的关键两步：</p><ol><li>将样本点分配给最近的质心：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_closest_centroids</span>(<span class="params">X, centroids</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    计算每个实例的质心隶属度  </span></span><br><span class="line"><span class="string">    :param X: 形状为(m,n)的numpy数组，其中m是样本数量，n是特征数量。X中包含了m个数据点，每个数据点有n个特征  </span></span><br><span class="line"><span class="string">    :param centroids: 形状为(k,n)的numpy数组，k是质心的数量，每个质心也有n个特征  </span></span><br><span class="line"><span class="string">    :return: 一个形为(m,)的数组，表示每个数据点最近的质心的索引  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="comment"># 获取centroids的第一维度，就是获取质心的数量K </span></span><br><span class="line">    K = centroids.shape[<span class="number">0</span>]   </span><br><span class="line">    <span class="comment"># 创建一个全零的数组idx，长度为m，用于存储每个数据点最近的质心的索引  </span></span><br><span class="line">    idx = np.zeros(X.shape[<span class="number">0</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]): <span class="comment"># 每个实例  </span></span><br><span class="line">        distance = []  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(K): <span class="comment"># 每个质心  </span></span><br><span class="line">        <span class="comment"># 欧几里得距离来进行计算距离  </span></span><br><span class="line">            norm_ij = np.linalg.norm(X[i] - centroids[j]) </span><br><span class="line">            distance.append(norm_ij)  </span><br><span class="line">        <span class="comment"># 找到最近质心的索引  </span></span><br><span class="line">        idx[i] = np.argmin(distance)    </span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure></li><li>使用分配给每个质心的点重新计算平均值: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_centroids</span>(<span class="params">X, idx, K</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    用于计算新的质心，分配给每个质心的数据点的平均值  </span></span><br><span class="line"><span class="string">    :param X::param idx::param K::return:   </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    m, n = X.shape  </span><br><span class="line">    <span class="comment"># 创建一个形状为(K,n)的numpy数组，用来存储计算得到的新质心  </span></span><br><span class="line">    centroids = np.zeros((K, n))    </span><br><span class="line">    <span class="comment"># 计算新质心  </span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K):  </span><br><span class="line">    <span class="comment"># 找到所有分配给当前质心k的数据点  </span></span><br><span class="line">        points_assigned_to_k = X[idx == k]  </span><br><span class="line">        <span class="keyword">if</span> points_assigned_to_k.size &gt; <span class="number">0</span>:   <span class="comment"># 确保有点被分配  </span></span><br><span class="line">            centroids[k] = np.mean(points_assigned_to_k, axis=<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure></li></ol><h3 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h3><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p><mark>谱聚类是基于图的聚类</mark></p><p>聚类可以理解为：让距离更近的样本聚集在一起，距离远的样本分到不同的簇中。<br>我们可以用权重来表示距离大小(相似性)。那么聚类的过程就可以说成把数据集切开，切成需要的份数，最终的结果就是每个子集里面的样本呢权重尽可能大，子集之间被切断的权重尽可能小。那么聚类的关键问题就是：<mark>我们应该怎么去切这个数据集？</mark>而谱聚类的关注点就是解决这个问题。</p><h5 id="谱聚类的整体步骤"><a href="#谱聚类的整体步骤" class="headerlink" title="谱聚类的整体步骤"></a>谱聚类的整体步骤</h5><ol><li>基于已有的数据集进行构图</li><li>基于构好的图进行切图</li></ol><h5 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h5><p>我们要进行构图，要构造什么样的图呢？<br>介绍一些索然无味的概念。</p><blockquote><p>对于一个图G，我们通常描述为G(V,E)  其中的V是点的集合(也就是我们的数据集)，E是边的集合。我们定义两个点之间的权重为w，由于是无向图w_ij &#x3D; w_ji 。 有连接的两个点w&gt;0，没有连接的两个点，w&#x3D;0。</p></blockquote><blockquote><p>对于任意一个点，我们给它定义一个度（d_i），一个点的度就是这个点和它相连的所有点的权重之和。$$ d_i &#x3D; \sum_{j&#x3D;1}^{n} w_{ij} $$<br>我们再在度这个概念之上，定义一个度矩阵，度矩阵是一个n阶主对角方阵，n就是图中标的节点数。<br>$$D &#x3D; \begin{pmatrix}<br>d_1 &amp; 0 &amp; \cdots &amp; 0 \<br>0 &amp; d_2 &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; \cdots &amp; d_n \<br>\end{pmatrix}$$<br>有两个令人好奇的点，一是这个矩阵为什么要定义成方阵呢？二是为什么只有主对角线上有数据呢？<br>为什么是方阵？这是一个很有趣的问题，但是答案很无趣，因为定义。只是为了将矩阵的维度与节点的数量进行匹配。<br>为什么只有主对角线上有数据？因为度只跟该节点本身有关，不涉及节点之间的具体连接关系。非对角线上的0表示节点之间没有直接的联系。</p></blockquote><blockquote><p> 一个图我们已经有点集合了，那关键的就是边，也就是权重，我们把所有样本点的权重组成的矩阵，称之为邻接矩阵W，邻接矩阵也是一个n阶方阵。<br> $$<br>W &#x3D; \begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{bmatrix}<br>$$<br> 构建邻接矩阵方法主要有三种：  ϵ-邻近法，K邻近法、全连接法</p></blockquote><p>我们讨论一些这三种方法：</p><ol><li>ϵ-邻近法<br> s_ij是点i和点j之间的欧氏距离，我们提出一个距离阈值ϵ。我们来定义邻接矩阵：$$<br>w_{ij} &#x3D;<br>\begin{cases}<br>0, &amp; \text{if } s_{ij} &gt; \epsilon \<br>\epsilon, &amp; \text{if } s_{ij} \leq \epsilon<br>\end{cases}<br>$$<br> 这样邻接矩阵只有两种数据，表达的也只是有边还是没边。<br> 比如： $$<br>W &#x3D; \begin{bmatrix}<br>0 &amp; 1 &amp; \cdots &amp; 1 \<br>1 &amp; 0 &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 1 &amp; \cdots &amp; 0<br>\end{bmatrix}<br>$$<br> 其中a_12表示节点1和节点2有边(有联系)，若为0则表示没边。<br> 这个方法的话表示距离远近就很不理想。</li><li>K邻近法<br> 利用遍历所有的样本点，取每个样本最近的k个点作为近邻，只有和样本距离最近的k个点之间有权重w&gt;0。<img src="/images/Pasted image 20241104194640.png" style="zoom:200%;"/></li><li>全连接法<br> $$<br>w_{ij} &#x3D; s_{ij} &#x3D; \exp\left(-\frac{||x_i - x_j||^2}{2\sigma^2}\right)<br>$$<br>全连接法是建立邻接矩阵最普遍的方法。</li></ol><p>构图方面，我们再提及一个<mark>拉普拉斯矩阵</mark>(L)<br>其实非常简单：L &#x3D; D - W</p><h6 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h6><p>我们的目标是将图G(V,E)切成相互没有连接的多个子图。</p><p>针对任意两个子图点的集合A,B⊂V，A∩B&#x3D;∅，我们提出切图权重：$$<br>W(A, B) &#x3D; \sum_{i \in A, j \in B} w_{ij}<br>$$<br>明显的，切图权重表达的是1图中的所有点，和2图中的所有点，两两权重之和。<br>如果这个切图权重大，就说明两个图中的点联系紧密，说明切得不好。</p><p>我们针对所有的子图（假设一共有m个）它们图中的点集是A_1, A_2……A_m，我们定义cut：<br>$$<br>cut(A_1, A_2, \ldots, A_m) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} W(A_i, \overline{A_i})<br>$$<br>这个式子表现了所有子图图之间的权重，最小化cut，那就使得子图联系最小，达成了切图。切成了一个又一个联系小甚至没有联系的子图。</p><img src="/images/Pasted image 20241104201735.png" style="zoom:200%;"/><p>如何去使得这个cut最小？我们提出两种切图方法：<br>RatioCut切图和Ncut切图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode76(最小覆盖子串)</title>
      <link href="/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/"/>
      <url>/2024/11/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-最小覆盖子串"><a href="#滑动窗口-最小覆盖子串" class="headerlink" title="滑动窗口(最小覆盖子串)"></a>滑动窗口(最小覆盖子串)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode76.png" alt="26" style="zoom:50%;" align="left"/><img src="/images/leetcode76.jpg" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>窗口中频率达到要求的字母数量&#x3D;t中的字母种量，就表明我们找到一个子串，但不一定是最小子串。<code>required == formed</code>。用两个数组来记录频率，巧妙地将ASCII码当做下标，使得字母和频率一一对应。<code>int tFreq[128] = &#123;0&#125;, windowFreq[128] = &#123;0&#125;;</code>。这个过程是<strong>扩展右边界</strong>的过程。</p></blockquote><blockquote><p>当找到一个子串时，我们就应该寻找下一个子串，这个时候就应收缩窗口，移动左边界。顺带长度。收缩之后，有可能减少的那个就是我们需要的那个，我们要检查一下满足的数量<code>formed</code>是否减少。这个过程就是<strong>收缩左边界的过程</strong>。</p></blockquote><blockquote><p>我在<code>left &lt; right</code>还是<code>left &lt;= right</code>这一点犯了一些迷糊。答案显然是后者，因为当<code>left == right</code>的时候，说明这个字符串只有一个字母，难道只有一个字母就不去检查更新了吗，肯定不对啊。随意这个时候还是应当进入循环，所以选择<code>&lt;=</code>。</p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">minWindow</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> window_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;, t_freq[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> required = <span class="number">0</span>, formed = <span class="number">0</span>, start = <span class="number">0</span>, min_len = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计t中每个字符出现的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; t[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t_freq[t[i]] == <span class="number">0</span>) required++;</span><br><span class="line">t_freq[t[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; <span class="built_in">strlen</span>(s))&#123;</span><br><span class="line"><span class="type">char</span> ch = s[right];</span><br><span class="line">whidow_freq[ch]++;</span><br><span class="line"><span class="keyword">if</span>(t_freq[ch] &gt; <span class="number">0</span> &amp;&amp; window_freq[ch] == t_freq[ch]) formed++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; formed == required)&#123;</span><br><span class="line"><span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; min_len)&#123;</span><br><span class="line">min_len = right - left + <span class="number">1</span>;</span><br><span class="line">start = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除左边字符并且更新窗口状态</span></span><br><span class="line"><span class="type">char</span> left_char = s[left];</span><br><span class="line">widow_freq[left_char]--;</span><br><span class="line"><span class="keyword">if</span>(t_freqp[left_char] &gt; <span class="number">0</span> </span><br><span class="line">&amp;&amp; window_freq[letf_char] &lt; t_freq[letf_char]) formed--;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min_len == INT_MAX) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span>* result = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(min_len+<span class="number">1</span>));</span><br><span class="line">result[min_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题感觉很难，但本质上是滑动窗口，对比分析一下基础的滑动窗口<a href="https://sorcerer.zeabur.app/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/" target="_blank">滑动窗口leetcode209(长度最小的子数组)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode904(水果成篮)</title>
      <link href="/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/"/>
      <url>/2024/10/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-水果成篮"><a href="#滑动窗口-水果成篮" class="headerlink" title="滑动窗口(水果成篮)"></a>滑动窗口(水果成篮)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode904.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>扩大和缩小</p></blockquote><p>如果满足要求，那就扩大右边界<br>如果不满足要求，就缩小左边界</p><p>怎么判断是否满足要求呢？种类数量，实现方法是用一个数组来存放每种水果放在篮子里的数量</p><p>同样存在while和if的选择，缩小时采用的是while，原因左边可能存在连续的并且内容一致的，要一直缩小到满足条件。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>* fruits, <span class="type">int</span> fruitsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> basket[<span class="number">100001</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录每种水果的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_num = <span class="number">0</span>, unique_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; fruitsSize)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被放入篮子，就将它添加到篮子中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(basket[fruits[right]] == <span class="number">0</span>) unique_num++;</span><br><span class="line"></span><br><span class="line">        basket[fruits[right]]++;</span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//当篮子中水果种类超过2时，移动左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(unique_num &gt; <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">            basket[fruits[left]]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(basket[fruits[left]] == <span class="number">0</span>) unique_num--;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新最大水果数量</span></span><br><span class="line"></span><br><span class="line">        max_num = (right - left &gt; max_num) ? (right - left) : max_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之逻辑回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h2><blockquote><p>逻辑回归是根据给定的数据集估算时间发生的概率，是一种分类</p></blockquote><blockquote><p>明明是分类为什么称作回归呢？<br>因为它的底层方法就是线性回归，逻辑回归是基于回归的伪回归算法。</p></blockquote><h2 id="实现基础的逻辑回归"><a href="#实现基础的逻辑回归" class="headerlink" title="实现基础的逻辑回归"></a>实现基础的逻辑回归</h2><h3 id="理解逻辑回归"><a href="#理解逻辑回归" class="headerlink" title="理解逻辑回归"></a>理解逻辑回归</h3><h4 id="逻辑函数的表达"><a href="#逻辑函数的表达" class="headerlink" title="逻辑函数的表达"></a>逻辑函数的表达</h4><p>回想线性方程<br>$$Z &#x3D; W^TX + b$$<br>对于直线，我们知道z的输出范围没有任何的限制，可以从负无穷到正无穷。但是，我们需要的是一个分类器，想要拿到两种结果，0或者1，所以我们需要输出范围为（0,1）的式子。<br>在线性方程的基础上达到规范输出范围这一目的，我们使用了Sigmoid函数$$σ(z) &#x3D; \frac{1}{1+e^{-z}}$$</p><img src="/images/Pasted image 20241028195414.png" style="zoom:200%;"/>图像很像s，就跟sigmoid沾上边了，所以拿到一个逻辑函数的名称。<p>我们在z的基础上进行的操作来达到控制范围的效果，我们就将z代入，就像下面这样。<br><img src="/images/Pasted image 20241028182720.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028190843.png" style="zoom:200%;"/><br>我们要明确最初的目标，是分类，只有两种结果，要么0要么1，那哪些判断为0哪些判断为1呢？<br>我们引入决策边界。边界内为一种情况，边界外为一种情况。<br>不难想到会有线性边界以及非线性边界<br>情况类似下图<br><img src="/images/Pasted image 20241028200239.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028183305.png" style="zoom:200%;"/></p><blockquote><p>所以，逻辑回归的整体思路是，先用逻辑函数把线性回归的结果 (-∞,∞)映射到(0,1)，再通过决策边界建立与分类的概率联系</p></blockquote><p>在二分类模型中，事件发生于不发生的概率之比$$\frac{p}{1-p}$$称作事件的几率。<br>几率的范围也是(0,1)，那我们就令<br>$$z &#x3D; log(\frac{p}{1-p})$$<br>也就是说，线性回归的结果等于对数几率。</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>自然，向线性回归一样，逻辑回归也需要我们判断拟合好与不好。</p><p>线性回归分析梯度下降时，我们就提出了，条条大路不一定都能通罗马，恰好线性回归的损失函数是一个碗罢了，只有一个最小。<br>那逻辑回归还会这么幸运吗？<br>并不是，逻辑函数的平方损失函数布满了局部最小值。<br><img src="/images/Pasted image 20241028183938.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028191058.png" style="zoom:200%;"/><br>这样一来，梯度下降难以实行啊。为了解决这个问题，我们得让它也像碗一样听话。</p><p>痛苦的根源是什么？有个e啊！还在分母上，怎么导也动不了啊！联想一下高考导数题，不难想到取对数。试一试，取对数情况很不错。</p><p>y要么为0要么为1，看一看对数的图像<br><img src="/images/Pasted image 20241028202156.png" style="zoom:200%;"/><br>如果是一根线，那么不管怎么个情况，0和1对应取到的值都是天壤之别。</p><p>一根不能满足，两根就可以。一正一负，很合适。看看下面三张图：<br><img src="/images/Pasted image 20241028185200.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028184731.png" style="zoom:200%;"/><br><img src="/images/Pasted image 20241028185001.png" style="zoom:200%;"/></p><p>取对数，图形就变得很乖了，看不出坑坑洼洼。<br><img src="/images/Pasted image 20241028191229.png" style="zoom:200%;"/><br>这下就适合梯度下降了。</p><p>化简一下：<br><img src="/images/Pasted image 20241028192104.png" style="zoom:200%;"/></p><p>接下来就是线性回归一样的梯度下降处理了<br><img src="/images/Pasted image 20241028192602.png" style="zoom:200%;"/></p><p>不难看出，求的偏导跟线性回归好像一样。<br>但是区别就在于f的表达式。</p><p>剩下的处理跟线性回归也就大差不差了。详情可见<a href="https://sorcerer.zeabur.app/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" target="_blank">机器学习之逻辑回归基础</a></p><p><br><br><br><br><br>写在最后，感谢这些文章和视屏的指点：<br><a href="https://juejin.cn/post/7057447537757650957">https://juejin.cn/post/7057447537757650957</a><br><a href="https://blog.csdn.net/weixin_48524215/article/details/131350759">https://blog.csdn.net/weixin_48524215/article/details/131350759</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/3.Cost%20function%20for%20logistic%20regression/C1_W3_Lab04_LogisticLoss_Soln.ipynb</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之线性回归基础</title>
      <link href="/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h2 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h2><h3 id="什么是回归"><a href="#什么是回归" class="headerlink" title="什么是回归"></a>什么是回归</h3><blockquote><p>回归问题是函数拟合问题，就是给定一些点的集合，用一个曲线或者方程去拟合，使得所有点都大致符合</p></blockquote><h3 id="什么是线性回归-1"><a href="#什么是线性回归-1" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h3><blockquote><p>拟合的是一条直线，那就是线性回归</p></blockquote><h2 id="实现基础的线性回归"><a href="#实现基础的线性回归" class="headerlink" title="实现基础的线性回归"></a>实现基础的线性回归</h2><h3 id="实现回归的本质"><a href="#实现回归的本质" class="headerlink" title="实现回归的本质"></a>实现回归的本质</h3><p>拿到一个<em>好方程</em>，输入已知量(自变量)，就能通过这个方程预测未知量(我们想要的数据)</p><h3 id="拟合的方程"><a href="#拟合的方程" class="headerlink" title="拟合的方程"></a>拟合的方程</h3><p>我们假设能够拟合的方程是:<br>$$<br>h_\theta(x) &#x3D; \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \ldots + \theta_n x_n<br>$$<br>为了一般化这个方程，我们引入常量x0&#x3D;1<br>$$ h_\theta(x_{n\times1)} &#x3D; \sum_{i&#x3D;0}^{n} \theta_i \cdot x_i &#x3D;<br>\theta_{n\times1}^Tx_{1\times n}$$<br>要实现回归，就找到一群系数θ，也就是一个θ向量，也称作特征分量。</p><h3 id="拟合的好坏评价"><a href="#拟合的好坏评价" class="headerlink" title="拟合的好坏评价"></a>拟合的好坏评价</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>这个函数用来衡量我们预测值和真实值之间的差距<br>$$ J(\theta_{n\times1}) &#x3D; \frac{1}{2}\sum_{i&#x3D;1}^m(h_\theta(x_{n_\times1})^{(i)} - y^{(i)})^2$$</p><blockquote><p>(预测值-真实值)的平方，然后对每一组训练数据进行累加<br>需要一提的是，1&#x2F;2不是必要的，只是为了简化推导（最小二乘法的思想）</p></blockquote><p>损失函数的值小，就表明我们的误差小，那么我们的问题就变成了求最小值。<br>求$${minJ\theta}$$</p><h3 id="拟合的算法"><a href="#拟合的算法" class="headerlink" title="拟合的算法"></a>拟合的算法</h3><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><p>显然损失函数是一个关于θ的二次函数，二次函数的图像不外乎像这样：<br><br><img src="/images/Pasted image 20241028030501.png" style="zoom:200%;"/><br>导数为零的时候自然就是损失最小的时候<br>求损失函数关于θ的导数：<br>$$导数 &#x3D; 2{x^T_{n\times1}}(y_{n\times1} - x_{n\times1}\theta_{n\times1})$$<br>令导数为零，得到：<br>$$\theta_{n\times1} &#x3D; (x^T_{n\times1}x_{n\times1})^{-1}x^T_{n\times1}y_{n\times1}$$<br>也就是说代入这个公式，就能拿到合适的θ向量，也就达成了目标。<br>代码实现也不是很困难</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">standRegres</span>(<span class="params">xArr, yArr</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    函数说明：计算回归系数theta  </span></span><br><span class="line"><span class="string">    :param xArr: x数据集  </span></span><br><span class="line"><span class="string">    :param yArr: y数据集  </span></span><br><span class="line"><span class="string">    :return: 无  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    xMat = np.asmatrix(xArr)  </span><br><span class="line">    yMat = np.asmatrix(yArr).T  </span><br><span class="line">    xTx = xMat.T * xMat  </span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(xTx) == <span class="number">0.0</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;矩阵为奇异矩阵，不能求逆&#x27;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    theta = xTx.I * (xMat.T * yMat)  </span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><p><em>但是我们应该发现，这个公式中含有逆矩阵，然而现实中往往数据不可逆，因此最小二乘法不能适用于所有模型，而且，我们希望模型是不断从数据样本中学到有用的东西，而不是一步求解。</em><br>我们应该找一种更普遍的方法，目光看向梯度下降。</p><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><h5 id="理解思路"><a href="#理解思路" class="headerlink" title="理解思路"></a>理解思路</h5><p>直观说梯度下降法的话，就是：</p><blockquote><p>我站在高山上，我想用最短的时间下山，但是每次只能走一步。那么我需要做的就是环顾一周，找到一个最陡峭的方向，然后移动到那个点上；到新位置之后，重复刚才的动作。每次都选择最陡峭的方向走，那么很快就能下山。</p></blockquote><p>就像这样：<br><img src="/images/Pasted image 20241026163100.png" style="zoom:300%;"/><br>条条道路通罗马，但是从图像来看，不同起点到的最低点不一定一样<br>那是不是需要从所有地方出发，拿到所有情况呢？</p><p>答案是否定的<br>因为损失函数的图长这样：<br><img src="/images/Pasted image 20241026163114.png" style="zoom:200%;"/><br>不用担心，它就是一个碗而已。</p><p>既然行得通，我们就放心考虑思路<br>最小梯度法的整体思路就是：<br>    1. 对θ进行赋值，这个值随机，通常复值一个全零的向量<br>    2. 不停迭代，每次迭代都改变θ，使得损失函数按照梯度下降的方向进行减少</p><h5 id="具体落实"><a href="#具体落实" class="headerlink" title="具体落实"></a>具体落实</h5><p>确定了下山要一步一步走，具体怎么落实呢？<br>很简单：找一个方向，走一步</p><ul><li><p><strong>找一个方向</strong></p><blockquote><p>下山哪个方向才是最陡峭的呢？<br>  首先想到的是斜率，在我数学知识不多的印象中：斜率越大越陡峭<br>  通过斜率又不难想到导数，所以这定是与导数相关的。<br>  简而言之就是<em>这一步</em>由<em>上一步的基础</em>和<em>某个导数</em>确定$$这一步 &#x3D; 上一步 ？ 某导数$$<br>  推不下去了，就拿出结论吧：$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$  </p></blockquote></li><li><p><strong>走一步</strong></p><blockquote><p>一步走多远？<br>上面式子中的α称为学习率(learning rate)，直白的说就是每一步的步长。<br>    1.α太大可能错过最小值，最后不收敛<br>        想象一下一个人一步可以跨的很大，大到可以从这个山头跨到那个山头，那么这个人就永远不能下山，一直在两个山头反复横跳<br>    2.α太小又会迭代很多次，消耗资源<br>        想象一下小碎步下山<br>拿张图就明白了<br><img src="/images/Pasted image 20241027162552.png" style="zoom:200%;"/></p></blockquote></li></ul><p>下山的关键就是那个迭代公式！<br>$$\theta_j &#x3D; \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})$$<br>对损失函数 ∇J(θ) 关于参数 θ 的偏导数（梯度）是：<br>$$∇J(θ) &#x3D; \frac{\partial J(\theta)}{\partial\theta} &#x3D; \frac{2}{m} X^T(X\theta - y)$$</p><p>数学转换，得到：<br>$$θ &#x3D; θ - \alpha(\frac{2}{m} X^T(X\theta - y))$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加偏置项</span></span><br><span class="line">X_b = np.c_[np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>)), X]  <span class="comment"># 在X的前面加一列1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">alpha = <span class="number">0.1</span>  <span class="comment"># 学习率</span></span><br><span class="line">iterations = <span class="number">1000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 随机初始化权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降算法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    predictions = X_b.dot(theta)  <span class="comment"># 计算预测值</span></span><br><span class="line">    errors = predictions - y  <span class="comment"># 计算误差</span></span><br><span class="line">    gradients = (<span class="number">2</span> / <span class="built_in">len</span>(X_b)) * X_b.T.dot(errors)  <span class="comment"># 计算梯度</span></span><br><span class="line">    theta -= alpha * gradients  <span class="comment"># 更新权重</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最终的权重</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终的权重:&quot;</span>, theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习率通过不断尝试，得到最佳</p><p>还值得一提的是：</p><h5 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h5><p>为什么缩放？<br>特征值的范围是有差距的，有的特征影响大，有的影响小<br>就像你要竞选主席，你是中国公民这一特征的影响就远远小于你政治能力地位这一特征<br><img src="/images/Pasted image 20241027150630.png" style="zoom:200%;"/></p><p>为了让机器在读取数据的时候感觉更“舒服”，训练起来效率更高，还需要进行特征的缩放<br><img src="/images/Pasted image 20241027150856.png" style="zoom:200%;"/></p><p>特征缩放的常用方法</p><ul><li>最大值缩放 <img src="/images/Pasted image 20241028060744.png" style="zoom:200%;"/></li><li>均值归一化<img src="/images/Pasted image 20241027151409.png" style="zoom:200%;"/></li><li>Z-score 标准化<img src="/images/Pasted image 20241027151659.png" style="zoom:200%;"/></li></ul><p><br><br><br><br><br>放一些练手的连接，怕自己忘记了<br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/5.Week%202%20practice%20lab%20Linear%20regression/.ipynb_checkpoints/C1_W2_Linear_Regression%20-%20%E5%89%AF%E6%9C%AC-checkpoint.ipynb" target="_blank">使用一个变量实施线性回归，以预测餐厅特许经营的利润</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab05_Sklearn_GD_Soln.ipynb" target="_blank">利用 scikit-learn 使用 Gradient Descent 实现线性回归</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/work/C1_W2_Lab06_Sklearn_Normal_Soln.ipynb" target="_blank">利用 scikit-learn 使用基于正态方程的紧密形式解实现线性回归</a><br><br><br><br><br>写在最后，感谢这些文章和视频对我的指点：<br><a href="https://www.kaggle.com/code/tohuangjia/linear-regression">https://www.kaggle.com/code/tohuangjia/linear-regression</a><br><a href="https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html">https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html</a><br><a href="https://blog.csdn.net/didiaopao/article/details/126483324">https://blog.csdn.net/didiaopao/article/details/126483324</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Unsupervised%20learning%20recommenders%20reinforcement%20learning/week1/2%20Practice%20Lab1/.ipynb_checkpoints/C3_W1_KMeans_Assignment-checkpoint.ipynb</a><br><a href="https://njuferret.github.io/2017/08/24/Gradient-Descent/">https://njuferret.github.io/2017/08/24/Gradient-Descent/</a><br><a href="https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html">https://www.cnblogs.com/renly/archive/2013/01/04/2844880.html</a><br><a href="https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&vd_source=696b6322fafa5344c9a7c99a18c22374">https://www.bilibili.com/video/BV1PN4y1V7d9/?p=3&amp;vd_source=696b6322fafa5344c9a7c99a18c22374</a><br><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/6.Train%20the%20model%20with%20gradient%20descent/C1_W1_Lab05_Gradient_Descent_Soln.ipynb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 最小二乘法 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口leetcode209(长度最小的子数组)</title>
      <link href="/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/"/>
      <url>/2024/10/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口-长度最小的子数组"><a href="#滑动窗口-长度最小的子数组" class="headerlink" title="滑动窗口(长度最小的子数组)"></a>滑动窗口(长度最小的子数组)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/images/leetcode209.png" alt="26" style="zoom:50%;" align="left"/><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>跟一般思维不一样的是，滑动窗口不是往后面进行遍历，关注点在前面</li><li>如何移动初始指针<ul><li>很奇妙的一个点在于 <code>sum = sum - nums[i]</code> ，这样求和就不用再进行遍历</li></ul></li><li>为什么选择 <code>while</code> 而不用 <code>if</code><ul><li><code>if</code> 只执行一次，一次之后集合之和还是大于 <code>target</code> 就不对了，用while的话还能够将 <code>left</code> 向后移动，直到满足 <code>sum &gt;= target</code></li></ul></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;numsSize; j++)&#123;</span><br><span class="line"></span><br><span class="line">        sum += nums[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line"></span><br><span class="line">            sum -= nums[i];</span><br><span class="line"></span><br><span class="line">            len = j - i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            result = len &lt; result ? len : result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方leetcode977(双指针经典)</title>
      <link href="/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/"/>
      <url>/2024/10/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode977.png" alt="24" align="left"/><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>用双指针，为什么要用双指针？怎么想到要用双指针？</p><p>分析题目，数据是开头大，结尾大，中间小，总体成两边高中间矮的情形，就应该想到比较首尾，就应该联想到双指针。</p><p>如果i比j大，放入i，然后i++，如果j比i大，放如j，然后j–。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .Note: The returned array must be malloced, assume caller calls free()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line">    <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> , j=numsSize<span class="number">-1</span> ; i&lt;=j ; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]*nums[j]&gt;nums[i]*nums[i])&#123;</span><br><span class="line">            result[k] = nums[j]*nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k] = nums[i]*nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎笔(2024.10.14)</title>
      <link href="/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/"/>
      <url>/2024/10/14/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h4 id="一些碎笔"><a href="#一些碎笔" class="headerlink" title="一些碎笔"></a>一些碎笔</h4><p>进实验室大概有个把月吧，跟着也写了搜索引擎，今天进行了检查。老师很不满意。</p><p>说认真也认真，熬了夜的也是，说懒散也懒散，随随便便，想着写着。</p><p>加压？减压？不知道。明天？后天？不知道。痴呆？迟钝？不知道。</p><p>我本来觉着还不错，倒是凉水一盆，清醒了不少。</p><p>要求低了吧我对自己，也太容易飘飘然了吧。</p><p>收拾收拾，继续往前走吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode69(x的平方根)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-x的平方根"><a href="#二分查找-x的平方根" class="headerlink" title="二分查找(x的平方根)"></a>二分查找(x的平方根)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode69.png" alt="22" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>当  <code>middle *  middle &lt;= x</code>  的时候说明middle是潜在的答案，但是答案可能更大，我们要继续往右找，所以先记录  <code>ans = middle</code>  ，再将 left 刷新。</p></blockquote><blockquote><p>为了防止溢出，将  <code>middle *  middle &lt;= x</code>  改为 <code>middle &lt;=  x / middle</code>  </p></blockquote><blockquote><p>这里采用的是左闭右闭，这里注意的是原本  <code>right = x - 1</code>   改成了 <code>right == x</code>  (左闭右开同理)<br>区分基础二分法，因为基础中是基于数组的，最末下标是  <code>numsSize - 1</code>  ，本题不存在下标越界，最末就是 x ，左闭右开，<code>right == x + 1</code> ，左闭右闭，<code>right = x</code> </p></blockquote><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>, right = x, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode704(基础)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-基础"><a href="#二分查找-基础" class="headerlink" title="二分查找(基础)"></a>二分查找(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>有序数组，无重复元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>左闭右开，左闭右闭</p></blockquote><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><h6 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h6><img src="/images/leetcode704.png" alt="16" style="zoom:100%;" align="left"/><h6 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* num,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; num[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; num[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == nums[middle])</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,left,middle,target);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,middle + <span class="number">1</span>,right,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums,<span class="number">0</span>,numsSize,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>越界避免：可以将  <code>middle == (left + right)/2</code>  改成  <code>middle = right - (right - left)/2</code>  ，但是同时会增加运行时间。</p><p>（整数计算过程中也不能超过  <code>int</code>  的范围）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode367(有效的完全平方数)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-有效的完全平方数-、"><a href="#二分查找-有效的完全平方数-、" class="headerlink" title="二分查找(有效的完全平方数)、"></a>二分查找(有效的完全平方数)、</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode367.png" alt="23" style="zoom:100%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>这道题主要是防止溢出 <code>long long ride = (long long)middle * middle</code>  ，还有就是  <code>int middle = right - (right - left)/2</code>  ，要思考的点在于，什么时候用 <code>right - (right - left)/2</code>  代替  <code>(right + left)/2</code>  ，注意根据具体题目判断是否会越 <code>int</code> 界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 排除非正数的情况</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = num;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = right - (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ride = (<span class="type">long</span> <span class="type">long</span>)middle * middle;</span><br><span class="line">        <span class="keyword">if</span>(ride == num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ride &lt; num)&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode35(搜索插入位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-搜索插入位置"><a href="#二分查找-搜索插入位置" class="headerlink" title="二分查找(搜索插入位置)"></a>二分查找(搜索插入位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode35.png" alt="17" style="zoom:80%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>要是没有找到，哪一个才是插入坐标？(主要针对左闭右开)</p></blockquote><p>没有找到时，left是等于right的，其实是等于上一次的middle的(二分查找过程中是逼近target的过程)，上一次的middle就是target，所以没找到时，应当返回right或者left+1</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums [middle] == target)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找leetcode34(查找元素的第一个和最后一个位置)</title>
      <link href="/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/"/>
      <url>/2024/09/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找-查找元素的第一个和最后一个位置"><a href="#二分查找-查找元素的第一个和最后一个位置" class="headerlink" title="二分查找(查找元素的第一个和最后一个位置)"></a>二分查找(查找元素的第一个和最后一个位置)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode34.png" alt="21" style="zoom:60%;" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><p>两种方向：</p><ol><li>通过基础的二分法找到target然后左右扩散，找到最左和最右(第一步二分，第二步遍历，适用于target重复数量不是特别大)</li><li>将  <code>nums[middle]==target</code>  的时候不返回，继续收缩(全是二分法，适用于target重复数量很大</li></ol><p>​寻找左边界的时候，<code>nums[middle]==target</code>  不能停止，因为左边也许还有，所以要继续收缩右边界</p><p>​同理，寻找右边界时，找到了相等还应当继续收缩左边界</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findTarget</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[middle])&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">findBorder</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target,<span class="type">int</span> border,<span class="type">int</span>* result)</span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = border;</span><br><span class="line">    result[<span class="number">1</span>] = border;</span><br><span class="line">    <span class="type">int</span> leftBorder = border;</span><br><span class="line">    <span class="type">int</span> rightBorder = border;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(border != <span class="number">0</span>)&#123;<span class="comment">//需要找左边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(leftBorder &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[leftBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftBorder--;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>] = leftBorder + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(border != numsSize - <span class="number">1</span>)&#123;<span class="comment">//需要找右边的情况</span></span><br><span class="line">        <span class="keyword">while</span>(rightBorder &lt; numsSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[rightBorder] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rightBorder++;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">1</span>] = rightBorder - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   * returnSize = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">   result[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">   <span class="type">int</span> target0 = findTarget(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">if</span>(target0 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> findBorder(nums,numsSize,target,target0,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[middle])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; numsSize &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findLast</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; nums[right - <span class="number">1</span>] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">searchRange</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">   *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">   result[<span class="number">0</span>] = findFirst(nums,numsSize,target);</span><br><span class="line">   result[<span class="number">1</span>] = findLast(nums,numsSize,target);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode26(删除有序数组中的重复项)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-删除有序数组中的重复项"><a href="#移除元素-删除有序数组中的重复项" class="headerlink" title="移除元素(删除有序数组中的重复项)"></a>移除元素(删除有序数组中的重复项)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="\images\leetcode26.png" alt="25" style="zoom:50%;" align="left" /><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>与基础双指针相比，本题为什么  <code>fastIndex = 1</code>   而不等于0，为什么先  <code>slowIndex++</code> 后赋值</p></blockquote><p>​     基础的给定了一个target，fast从零开始排查，而本题，是删除重复元素，不用排查第一个</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="正确解答"><a href="#正确解答" class="headerlink" title="正确解答"></a>正确解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            slowIndex++;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="错误解答"><a href="#错误解答" class="headerlink" title="错误解答"></a>错误解答</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="正误对比分析"><a href="#正误对比分析" class="headerlink" title="正误对比分析"></a>正误对比分析</h6><blockquote><p>本题没有给target，所以需要自行判断target，我们采用的方法就是后者比较前者，所以fast和slow要有差</p></blockquote><p>​     虽然两种解答乍一看是一样的，但是错误解答中就忽略了二者必须有差这一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode27(基础)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-基础"><a href="#移除元素-基础" class="headerlink" title="移除元素(基础)"></a>移除元素(基础)</h4><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><blockquote><p>数组，移除指定内容的元素</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><p>暴力解法，遍历，找到元素就将后一个内容赋给前一个</p></blockquote><blockquote><p>快慢指针法，遍历，任何时候都将快指针前移，没有找到元素的时候，快指针内容赋值给慢指针，慢指针前移</p></blockquote><p>​     <a href="https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3">https://www.bilibili.com/video/BV1ep4y1S7zv?vd_source=67ccdc6b6c70370ff009abdf5c7dc2d3</a> ( 1分55 )<br>   【Leetcode 27 移除元素 【快慢指针】】</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode27.png" alt="24" align="left"/><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-暴力"><a href="#解法1-暴力" class="headerlink" title="解法1(暴力)"></a>解法1(暴力)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;<span class="comment">//如果找到一样的，那么后面的元素依次往前移动</span></span><br><span class="line">                nums[j<span class="number">-1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;<span class="comment">//下标i以后的数值都向前移动了一位，i也要往前移动一位</span></span><br><span class="line">            numsSize--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-快慢指针法"><a href="#解法2-快慢指针法" class="headerlink" title="解法2(快慢指针法)"></a>解法2(快慢指针法)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="type">int</span> fast_index = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> slow_index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(fast_index=<span class="number">0</span>;fast_index&lt;numsSize;fast_index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast_index] != val)&#123;</span><br><span class="line">            nums[slow_index] = nums[fast_index];</span><br><span class="line">            slow_index++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode844(比较含退格元素的字符串)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-比较含退格的字符串"><a href="#移除元素-比较含退格的字符串" class="headerlink" title="移除元素(比较含退格的字符串)"></a>移除元素(比较含退格的字符串)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode844.png" alt="3" style="zoom:90%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>其实思路都是得到处理后的字符串进行比较，不同点就在于怎样处理字符串</p></blockquote><ol><li>每个字符串两个空间，一个用来遍历判断，一个用来存放处理后的字符</li></ol><p>​如果是退格符，就栈顶弹出；如果是普通字符，就压入栈中</p><ol start="2"><li><p>双指针</p><p>在原本的空间基础上进行处理。如果快指针不指向退格符，就将所指字符赋给慢指针指向的空间；如果快指针指向退格符，说明需要将慢指针所指向的内容删除就，慢指针后退，这里有一个易错点就是慢指针退到零了就退不了了，要注意下标不要越界。</p></li></ol><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解法1-两个数组空间"><a href="#解法1-两个数组空间" class="headerlink" title="解法1(两个数组空间)"></a>解法1(两个数组空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str), len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (n + <span class="number">1</span>)); <span class="comment">//多一个用来存放终止符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            ret[len++] == str[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s),build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解法2-双指针-一个空间"><a href="#解法2-双指针-一个空间" class="headerlink" title="解法2(双指针,一个空间)"></a>解法2(双指针,一个空间)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">build</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex; str[fastIndex] != <span class="string">&#x27;\0&#x27;</span>; fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[fastIndex] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            str[slowIndex++] = str[fastIndex];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(slowIndex &gt; <span class="number">0</span>)&#123;<span class="comment">//这里的判断条件容易忽略</span></span><br><span class="line">            slowIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str[slowIndex] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">backspaceCompare</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(build(s), build(t)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素leetcode283(移动零)</title>
      <link href="/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/"/>
      <url>/2024/09/25/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0(%E7%A7%BB%E5%8A%A8%E9%9B%B6)/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素-移动零"><a href="#移除元素-移动零" class="headerlink" title="移除元素(移动零)"></a>移除元素(移动零)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><img src="/images/leetcode283.png" alt="26" style="zoom:50%;" align="left"/><h5 id="理解关键点"><a href="#理解关键点" class="headerlink" title="理解关键点"></a>理解关键点</h5><blockquote><p>为什么要调换位置</p></blockquote><p>​     遍历时，如果没有遍历过0元素，那么fast和slow指针的位置始终相同，交换位置不会影响结果。一旦遍历过0元素，那么slow就停到最左边零的位置，此时当right遍历到非零元素时，就会和最左边的零互换。</p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><h6 id="解答1-双循环"><a href="#解答1-双循环" class="headerlink" title="解答1(双循环)"></a>解答1(双循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(slowIndex;slowIndex&lt;numsSize;slowIndex++)&#123;</span><br><span class="line">        nums[slowIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解答2-单循环"><a href="#解答2-单循环" class="headerlink" title="解答2(单循环)"></a>解答2(单循环)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fastIndex;fastIndex&lt;numsSize;fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp = nums[fastIndex];</span><br><span class="line">            nums[fastIndex] = nums[slowIndex];</span><br><span class="line">            nums[slowIndex] = temp;</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 移除元素 </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
